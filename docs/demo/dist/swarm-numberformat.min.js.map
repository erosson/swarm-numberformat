{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///swarm-numberformat.min.js","webpack:///webpack/bootstrap fddd44a542f0678b992a","webpack:///./src/format.js","webpack:///./~/decimal.js/decimal.es6.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/long-scale-suffixes.json","webpack:///./src/standard-suffixes.json"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","global","_classCallCheck","instance","Constructor","TypeError","log","requireDecimal","Decimal","window","validate","condition","message","Error","_format","val","opts","backend","backends","normalize","index","suffix","suffixFn","sigfigs","undefined","Math","abs","maxSmall","toPrecision","rounding","replace","minSuffix","floor","toLocaleString","prefix","toExponential","__WEBPACK_IMPORTED_MODULE_0__standard_suffixes_json__","__WEBPACK_IMPORTED_MODULE_0__standard_suffixes_json___default","__WEBPACK_IMPORTED_MODULE_1__long_scale_suffixes_json__","__WEBPACK_IMPORTED_MODULE_1__long_scale_suffixes_json___default","Formats","Formatter","format","formatFull","formatShort","log10","ret","LN10","round","native","max","_ref","pow","decimal.js","_requireDecimal","config","constructor","clone","_ref2","e","_ref3","div","dividedBy","defaultOptions","flavor","suffixGroup","suffixes","suffixGroups","length","minSuffixSigfigs","standard","a","longScale","scientific","full","short","hybrid","slice","engineering","Flavors","formats","flavors","_this","arguments","keys","_normalizeOpts","key","charAt","toUpperCase","substr","formatFlavor","assign","formatOptions","flavorOptions","listFormats","numberformat","__WEBPACK_IMPORTED_MODULE_0__format__","digitsToString","k","ws","indexOfLastWord","str","w","LOG_BASE","getZeroString","checkInt32","min","invalidArgument","checkRoundingDigits","rm","repeating","di","r","rd","ceil","mathpow","convertBase","baseIn","baseOut","j","arrL","arr","strL","NUMERALS","indexOf","reverse","cosine","Ctor","x","y","len","toString","precision","taylorSeries","times","cos2x","minus","plus","finalise","sd","isTruncated","digits","roundUp","xd","xdi","out","push","BASE","pop","external","maxE","NaN","minE","finiteToString","isExp","isFinite","nonFiniteToString","getBase10Exponent","getLn10","pr","LN10_PRECISION","precisionLimitExceeded","getPi","PI_PRECISION","PI","getPrecision","zs","intPow","truncate","mathfloor","isOdd","maxOrMin","args","ltgt","naturalExponential","denominator","guard","sum","t","wpr","rep","divide","naturalLogarithm","c0","numerator","x1","x2","String","parseDecimal","search","substring","charCodeAt","parseOther","base","divisor","isFloat","xe","isHex","test","toLowerCase","isBinary","isOctal","sine","sqrt","sin2_x","d5","d16","d20","isHyperbolic","u","toLessThanHalfPi","isNeg","pi","halfPi","lte","quadrant","divToInt","isZero","toStringBinary","MAX_DIGITS","inexact","unshift","acos","acosh","add","asin","asinh","atan","atanh","atan2","cbrt","obj","decimalError","v","ps","EXP_LIMIT","crypto","getRandomValues","randomBytes","cryptoUnavailable","cos","cosh","isDecimal","P","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","set","exp","hypot","ln","log2","mod","mul","random","sign","sin","sinh","sub","tan","tanh","trunc","Uint32Array","copy","shift","ln10","defaults","modulo","toExpNeg","toExpPos","absoluteValue","comparedTo","cmp","xdL","ydL","yd","xs","ys","neg","cubeRoot","t3","t3plusx","eq","decimalPlaces","dp","dividedToIntegerBy","equals","greaterThan","gt","greaterThanOrEqualTo","gte","hyperbolicCosine","one","cosh2_x","d8","hyperbolicSine","sinh2_x","hyperbolicTangent","inverseCosine","inverseHyperbolicCosine","inverseHyperbolicSine","inverseHyperbolicTangent","xsd","inverseSine","inverseTangent","px","isInteger","isInt","isNaN","isNegative","isPositive","isPos","lessThan","lt","lessThanOrEqualTo","logarithm","isBase10","inf","num","arg","xLTy","q","negated","carry","z","squareRoot","tangent","rL","toBinary","toDecimalPlaces","toDP","toFixed","toFraction","maxD","d0","d1","d2","n0","n1","toHexadecimal","toHex","toNearest","toNumber","toOctal","toPower","yIsInt","yn","toSignificantDigits","toSD","truncated","valueOf","toJSON","multiplyInteger","temp","compare","b","aL","bL","subtract","logBase","more","prod","prodL","qd","rem","remL","rem0","xi","xL","yd0","yL","yz","g","Function","eval"],"mappings":"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,GKhqKxBC,EAAAD,SACA2G,OACA,GACA,IACA,IACA,KACA,IACA,KACA,IACA,KACA,KACA,MACA,KACA,MACA,KACA,MACA,KACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,QAEAD,MACA,GACA,YACA,WACA,YACA,WACA,YACA,YACA,aACA,eACA,gBACA,eACA,gBACA,cACA,eACA,cACA,eACA,aACA,cACA,aACA,cACA,aACA,cACA,eACA,gBACA,gBACA,iBACA,gBACA,iBACA,qBACA,sBACA,oBACA,qBACA,eACA,gBACA,mBACA,oBACA,iBACA,kBACA,kBACA,mBACA,gBACA,iBACA,kBACA,mBACA,mBACA,oBACA,oBACA,qBACA,wBACA,yBACA,uBACA,wBACA,mBACA,oBACA,sBACA,uBACA,oBACA,qBACA,qBACA,sBACA,iBACA,kBACA,mBACA,oBACA,oBACA,qBACA,qBACA,sBACA,yBACA,0BACA,wBACA,yBACA,oBACA,qBACA,uBACA,wBACA,qBACA,sBACA,sBACA,uBACA,oBACA,qBACA,sBACA,0BLwqKM,SAAUzG,EAAQD,GMz1KxBC,EAAAD,SACA2G,OACA,GACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,MACA,OAEAD,MACA,GACA,YACA,WACA,WACA,YACA,eACA,eACA,cACA,cACA,aACA,aACA,aACA,eACA,gBACA,gBACA,qBACA,oBACA,eACA,mBACA,iBACA,kBACA,gBACA,kBACA,mBACA,oBACA,wBACA,uBACA,mBACA,sBACA,oBACA,qBACA,iBACA,mBACA,oBACA,qBACA,yBACA,wBACA,oBACA,uBACA,qBACA,sBACA,oBACA,sBACA,uBACA,wBACA,4BACA,2BACA,uBACA,0BACA,wBACA,yBACA,qBACA,uBACA,wBACA,yBACA,6BACA,4BACA,wBACA,2BACA,yBACA,0BACA,kBACA,oBACA,qBACA,qBACA,0BACA,yBACA,oBACA,wBACA,sBACA,uBACA,oBACA,sBACA,uBACA,uBACA,4BACA,2BACA,sBACA,0BACA,wBACA,yBACA,kBACA,oBACA,wBNi2KM,SAAUzG,EAAQD,EAASM,GAEjCL,EAAOD,QAAUM,EAAoB","file":"swarm-numberformat.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"numberformat\"] = factory();\n\telse\n\t\troot[\"numberformat\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"numberformat\"] = factory();\n\telse\n\t\troot[\"numberformat\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__standard_suffixes_json__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__standard_suffixes_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__standard_suffixes_json__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__long_scale_suffixes_json__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__long_scale_suffixes_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__long_scale_suffixes_json__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Formats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Formatter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return formatFull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return formatShort; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Can't comment a .json file, but the suffixes come from these pages:\n// http://home.kpn.nl/vanadovv/BignumbyN.html\n\n\n\nfunction log() {}\n//console.log(...mess)\n\n// Lazy-load - we might not need decimal. It's a peerDependency, so the parent\n// library must include it if needed - we don't, because many callers don't need\n// it.\nvar Decimal = void 0;\nfunction requireDecimal() {\n  return Decimal || (Decimal = function () {\n    if (global && global.Decimal) {\n      log('swarm-numberformat decimal.js: Found global.Decimal');\n      return global.Decimal;\n    }\n    if (global && global.window && window.Decimal) {\n      log('swarm-numberformat decimal.js: Found window.Decimal');\n      return window.Decimal;\n    }\n    log('swarm-numberformat decimal.js: trying require()');\n    return __webpack_require__(2);\n  }());\n}\n// TODO: use this page to generate names dynamically, for even larger numbers:\n//   http://mathforum.org/library/drmath/view/59154.html\n\nfunction validate(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n  return condition;\n}\n\n// polyfill IE and phantomjs\nvar log10 = function () {\n  if (!!Math.log10) {\n    return Math.log10;\n  }\n  return function (val) {\n    var ret = Math.log(val) / Math.LN10;\n    // bloody stupid rounding errors\n    ret = Math.round(ret * 1e6) / 1e6;\n    return ret;\n  };\n}();\n\nvar backends = {\n  'native': {\n    normalize: function normalize(val) {\n      return val;\n    },\n\n    // Suffixes are a list - which index of the list do we want?\n    // _index(999) === 0\n    // _index(1000) === 1\n    // _index(1000000) === 2\n    index: function index(val) {\n      // string length is faster but fails for length >= 20, where JS starts\n      // formatting with e\n      return Math.max(0, Math.floor(log10(Math.abs(val)) / 3));\n    },\n    prefix: function prefix(val, index, _ref) {\n      var sigfigs = _ref.sigfigs;\n\n      // `sigfigs||undefined` supports sigfigs=[null|0], #15\n      return (val / Math.pow(1000, index)).toPrecision(sigfigs || undefined);\n    }\n  },\n  'decimal.js': {\n    // api docs: https://mikemcl.github.io/decimal.js/\n    _requireDecimal: function _requireDecimal(config) {\n      if (!requireDecimal()) throw new Error('requireDecimal() failed');\n      return new requireDecimal()(0).constructor.clone(config);\n    },\n    normalize: function normalize(val, _ref2) {\n      var rounding = _ref2.rounding;\n\n      var Decimal = this._requireDecimal({ rounding: rounding });\n      return new Decimal(val);\n    },\n    index: function index(val) {\n      var Decimal = this._requireDecimal();\n      // index = val.log10().dividedToIntegerBy(Decimal.log 1000)\n      // Decimal.log() is too slow for large numbers. Docs say performance degrades exponentially as # digits increases, boo.\n      // Lucky me, the length is used by decimal.js internally: num.e\n      // this is in the docs, so I think it's stable enough to use...\n      val = new Decimal(val);\n      return Math.floor(val.e / 3);\n    },\n    prefix: function prefix(val, index, _ref3) {\n      var sigfigs = _ref3.sigfigs,\n          rounding = _ref3.rounding;\n\n      var Decimal = this._requireDecimal({ rounding: rounding });\n      var div = new Decimal(1000).pow(index);\n      // `sigfigs||undefined` supports sigfigs=[null|0], #15\n      return new Decimal(val).dividedBy(div).toPrecision(sigfigs || undefined);\n    }\n  }\n};\n\n// The formatting function.\nfunction _format(val, opts) {\n  var backend = validate(backends[opts.backend], 'not a backend: ' + opts.backend);\n  val = backend.normalize(val, opts);\n  var index = backend.index(val);\n  var suffix = opts.suffixFn(index);\n  // `{sigfigs: undefined|null|0}` for automatic sigfigs is supported.\n  var sigfigs = opts.sigfigs || undefined;\n  // optionally format small numbers differently: show decimals without trailing zeros\n  if (Math.abs(val) < opts.maxSmall) {\n    // second param for decimal.js only, native ignores it\n    return val.toPrecision(sigfigs, opts.rounding).replace(/(\\.\\d*[1-9])0+$/, '$1');\n  }\n  // opts.minSuffix: Use JS native formatting for smallish numbers, because\n  // '99,999' is prettier than '99.9k'\n  // it's safe to let Math coerce Decimal.js to infinity here, gt/lt still work\n  if (Math.abs(val) < opts.minSuffix) {\n    val = Math.floor(val);\n    return val.toLocaleString();\n  }\n  // No suffix found: use scientific notation. JS's native toExponential is fine.\n  if (!suffix && suffix !== '') {\n    if (!!sigfigs) {\n      sigfigs -= 1;\n    }\n    return val.toExponential(sigfigs).replace('e+', 'e');\n  }\n  // Found a suffix. Calculate the prefix, the number before the suffix.\n  var prefix = backend.prefix(val, index, opts);\n  return '' + prefix + suffix;\n}\n\nvar defaultOptions = {\n  backend: 'native',\n  flavor: 'full',\n  suffixGroup: 'full',\n  suffixFn: function suffixFn(index) {\n    var suffixes = this.suffixes || this.suffixGroups[this.suffixGroup];\n    validate(suffixes, 'no such suffixgroup: ' + this.suffixGroup);\n    if (index < suffixes.length) {\n      return suffixes[index] || '';\n    }\n    // return undefined\n  },\n\n  // minimum value to use any suffix, because '99,900' is prettier than '99.9k'\n  minSuffix: 1e5,\n  // don't use sigfigs for smallish numbers. #13\n  minSuffixSigfigs: false,\n  // Special formatting for numbers with a decimal point\n  maxSmall: 0,\n  sigfigs: 3, // often overridden by flavor\n  format: 'standard'\n};\n// User-visible format choices, like on swarmsim's options screen.\n// Each has a different set of options.\nvar Formats = {\n  standard: { suffixGroups: __WEBPACK_IMPORTED_MODULE_0__standard_suffixes_json___default.a },\n  // like standard formatting, with a different set of suffixes\n  longScale: { suffixGroups: __WEBPACK_IMPORTED_MODULE_1__long_scale_suffixes_json___default.a },\n  // like standard formatting, with no suffixes at all\n  scientific: { suffixGroups: { full: [], short: [] } },\n  // like standard formatting, with a smaller set of suffixes\n  hybrid: {\n    suffixGroups: {\n      full: __WEBPACK_IMPORTED_MODULE_0__standard_suffixes_json___default.a.full.slice(0, 12),\n      short: __WEBPACK_IMPORTED_MODULE_0__standard_suffixes_json___default.a.short.slice(0, 12)\n    }\n  },\n  // like standard formatting, with a different/infinite set of suffixes\n  engineering: { suffixFn: function suffixFn(index) {\n      return index === 0 ? '' : 'E' + index * 3;\n    } }\n};\n// A convenient way for the developer to modify formatters.\n// These are different from formats - not user-visible.\nvar Flavors = {\n  full: { suffixGroup: 'full', sigfigs: 5 },\n  short: { suffixGroup: 'short', sigfigs: 3 }\n};\n// Allow callers to extend formats and flavors.\ndefaultOptions.formats = Formats;\ndefaultOptions.flavors = Flavors;\n\nvar Formatter = function () {\n  /**\n   * @param {Object} opts All formatter configuration.\n   * @param {string} [opts.flavor='full'] 'full' or 'short'. Flavors can modify any number of other options here. Full is the default; short has fewer sigfigs and shorter standard-suffixes.\n   * @param {Object} [opts.flavors] Specify your own custom flavors.\n   * @param {string} [opts.backend='native'] 'native' or 'decimal.js'.\n   * @param {string} [opts.suffixGroup]\n   * @param {Function} [opts.suffixFn]\n   * @param {number} [opts.minSuffix=1e5]\n   * @param {number} [opts.maxSmall=0] Special formatting for numbers with a decimal point\n   * @param {number} [opts.sigfigs=5]\n   * @param {number} [opts.format='standard'] 'standard', 'hybrid', 'scientific', 'longScale'.\n   * @param {Object} [opts.formats] Specify your own custom formats.\n   */\n  function Formatter() {\n    var _this = this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Formatter);\n\n    /** @type Object */\n    this.opts = opts;\n    // create convenience methods for each flavor\n    var flavors = Object.keys(this._normalizeOpts().flavors);\n    // the fn(i) is for stupid binding tricks with the looped fn(val, opts)\n    for (var i = 0; i < flavors.length; i++) {\n      (function (i) {\n        var flavor = flavors[i];\n        // capitalize the first letter to camel-case method name, like formatShort\n        var key = 'format' + flavor.charAt(0).toUpperCase() + flavor.substr(1);\n        /** @ignore */\n        _this[key] = function (val, opts) {\n          return _this.formatFlavor(val, flavor, opts);\n        };\n      })(i);\n    }\n  }\n\n  Formatter.prototype._normalizeOpts = function _normalizeOpts() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // all the user-specified opts, no defaults\n    opts = Object.assign({}, this.opts, opts);\n    // opts.format redefines some other opts, but should never override the user's opts\n    var format = opts && opts.format;\n    var formats = opts && opts.formats || defaultOptions.formats;\n    var formatOptions = formats[format || defaultOptions.format];\n    validate(formatOptions, 'no such format: ' + format);\n    var flavor = opts && opts.flavor;\n    var flavors = opts && opts.flavors || defaultOptions.flavors;\n    var flavorOptions = flavors[flavor || defaultOptions.flavor];\n    validate(flavorOptions, 'no such flavor: ' + flavor);\n    // finally, add the implied options: defaults and format-derived\n    return Object.assign({}, defaultOptions, formatOptions, flavorOptions, opts);\n  };\n  /**\n   * @param {number} val\n   * @param {Object} [opts]\n   * @return {number} which suffix to use for this number in a list of suffixes. You can also think of this as \"how many commas are in the number?\"\n   */\n\n\n  Formatter.prototype.index = function index(val, opts) {\n    opts = this._normalizeOpts(opts);\n    return backends[opts.backend].index(val);\n  };\n  /**\n   * @param {number} val\n   * @param {Object} [opts]\n   * @return {string} The suffix that this number would use, with no number shown.\n   * @example\n   * new Formatter().suffix(1e6)\n   * // => \" million\"\n   * @example\n   * new Formatter().suffix(1e6, {flavor: \"short\"})\n   * // => \"M\"\n   */\n\n\n  Formatter.prototype.suffix = function suffix(val, opts) {\n    opts = this._normalizeOpts(opts);\n    var index = backends[opts.backend].index(val);\n    return opts.suffixFn(index);\n  };\n  /**\n   * Format a number.\n   * @param {number} val\n   * @param {Object} [opts] Override the options provided to the Formatter constructor.\n   * @return {string} The formatted number.\n   * @example\n   * new Formatter().format(1e6)\n   * // => \"1.0000 million\"\n   */\n\n\n  Formatter.prototype.format = function format(val, opts) {\n    opts = this._normalizeOpts(opts);\n    return _format(val, opts);\n  };\n  /**\n   * Format a number with a specified flavor. It's very common to call the formatter with different flavors, so it has its own shortcut.\n   *\n   * `Formatter.formatFull()` and `Formatter.formatShort()` are also available.\n   * @param {number} val\n   * @param {string} flavor 'short' or 'full'. See opts.flavor.\n   * @param {Object} [opts]\n   * @return {string} The formatted number.\n   * @example\n   * new Formatter().format(1e6, 'short')\n   * // => \"1.00M\"\n   */\n\n\n  Formatter.prototype.formatFlavor = function formatFlavor(val, flavor, opts) {\n    return this.format(val, Object.assign({}, opts, { flavor: flavor }));\n  };\n  /**\n   * @param {Object} [opts]\n   * @return {string[]} The complete list of formats available. Use this to build an options UI to allow your players to choose their favorite format.\n   */\n\n\n  Formatter.prototype.listFormats = function listFormats(opts) {\n    opts = this._normalizeOpts(opts);\n    return Object.keys(opts.formats);\n  };\n\n  return Formatter;\n}();\n\nvar numberformat = new Formatter();\nnumberformat.defaultOptions = defaultOptions;\nnumberformat.Formatter = Formatter;\n/* harmony default export */ __webpack_exports__[\"f\"] = numberformat;\n\n/**\n * Format a number using the default options.\n * @param {number} val\n * @param {Object} [opts]\n * @return string\n * @example\n * format(1e6)\n * // => \"1.0000 million\"\n * @example\n * format(1e6, {sigfigs: 1})\n * // => \"1 million\"\n */\nvar format = function format(val, opts) {\n  return numberformat.format(val, opts);\n};\n/**\n * Format a full-flavor number using the default options. Identical to `format()`\n * @param {number} val\n * @param {Object} [opts]\n * @return string\n * @example\n * format(1e6)\n * // => \"1.0000 million\"\n */\nvar formatFull = function formatFull(val, opts) {\n  return numberformat.formatFlavor(val, 'full', opts);\n};\n/**\n * Format a short-flavor number using the default options.\n * @param {number} val\n * @param {Object} [opts]\n * @return string\n * @example\n * format(1e6)\n * // => \"1.00M\"\n */\nvar formatShort = function formatShort(val, opts) {\n  return numberformat.formatFlavor(val, 'short', opts);\n};\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(3)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__format__ = __webpack_require__(0);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"Formats\", function() { return __WEBPACK_IMPORTED_MODULE_0__format__[\"a\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"Formatter\", function() { return __WEBPACK_IMPORTED_MODULE_0__format__[\"b\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return __WEBPACK_IMPORTED_MODULE_0__format__[\"c\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"formatFull\", function() { return __WEBPACK_IMPORTED_MODULE_0__format__[\"d\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"formatShort\", function() { return __WEBPACK_IMPORTED_MODULE_0__format__[\"e\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"numberformat\", function() { return __WEBPACK_IMPORTED_MODULE_0__format__[\"f\"]; });\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/*\r\n *\r\n *  decimal.js v7.2.1\r\n *  An arbitrary-precision Decimal type for JavaScript.\r\n *  https://github.com/MikeMcl/decimal.js\r\n *  Copyright (c) 2017 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  MIT Licence\r\n *  https://github.com/MikeMcl/decimal.js/LICENCE\r\n *\r\n */\r\n\r\n\r\n// -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n  // The maximum exponent magnitude.\r\n  // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\nvar EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n  // The limit on the value of `precision`, and on the value of the first argument to\r\n  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n  MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n  // Base conversion alphabet.\r\n  NUMERALS = '0123456789abcdef',\r\n\r\n  // The natural logarithm of 10 (1025 digits).\r\n  ln10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n  // Pi (1025 digits).\r\n  pi = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n  // The initial configuration properties of the Decimal constructor.\r\n  defaults = {\r\n\r\n    // These values must be integers within the stated ranges (inclusive).\r\n    // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n    // The maximum number of significant digits of the result of a calculation or base conversion.\r\n    // E.g. `Decimal.config({ precision: 20 });`\r\n    precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n    // The rounding mode used when rounding to `precision`.\r\n    //\r\n    // ROUND_UP         0 Away from zero.\r\n    // ROUND_DOWN       1 Towards zero.\r\n    // ROUND_CEIL       2 Towards +Infinity.\r\n    // ROUND_FLOOR      3 Towards -Infinity.\r\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    //\r\n    // E.g.\r\n    // `Decimal.rounding = 4;`\r\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n    rounding: 4,                           // 0 to 8\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n    // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN  6 The IEEE 754 remainder function.\r\n    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n    //\r\n    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n    // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n    // be used, but they may not give useful results.\r\n    modulo: 1,                             // 0 to 9\r\n\r\n    // The exponent value at and beneath which `toString` returns exponential notation.\r\n    // JavaScript numbers: -7\r\n    toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n    // The exponent value at and above which `toString` returns exponential notation.\r\n    // JavaScript numbers: 21\r\n    toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // JavaScript numbers: -324  (5e-324)\r\n    minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n    maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    crypto: false                          // true/false\r\n  },\r\n\r\n\r\n// ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n  Decimal, LN10, PI, inexact, quadrant,\r\n  external = true,\r\n\r\n  decimalError = '[DecimalError] ',\r\n  invalidArgument = decimalError + 'Invalid argument: ',\r\n  precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n  cryptoUnavailable = decimalError + 'crypto unavailable',\r\n\r\n  mathfloor = Math.floor,\r\n  mathpow = Math.pow,\r\n\r\n  isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n  isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n  isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n  isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n  BASE = 1e7,\r\n  LOG_BASE = 7,\r\n  MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n  LN10_PRECISION = ln10.length - 1,\r\n  PI_PRECISION = pi.length - 1,\r\n\r\n  // Decimal.prototype object\r\n  P = {};\r\n\r\n\r\n// Decimal prototype methods\r\n\r\n\r\n/*\r\n *  absoluteValue             abs\r\n *  ceil\r\n *  comparedTo                cmp\r\n *  cosine                    cos\r\n *  cubeRoot                  cbrt\r\n *  decimalPlaces             dp\r\n *  dividedBy                 div\r\n *  dividedToIntegerBy        divToInt\r\n *  equals                    eq\r\n *  floor\r\n *  greaterThan               gt\r\n *  greaterThanOrEqualTo      gte\r\n *  hyperbolicCosine          cosh\r\n *  hyperbolicSine            sinh\r\n *  hyperbolicTangent         tanh\r\n *  inverseCosine             acos\r\n *  inverseHyperbolicCosine   acosh\r\n *  inverseHyperbolicSine     asinh\r\n *  inverseHyperbolicTangent  atanh\r\n *  inverseSine               asin\r\n *  inverseTangent            atan\r\n *  isFinite\r\n *  isInteger                 isInt\r\n *  isNaN\r\n *  isNegative                isNeg\r\n *  isPositive                isPos\r\n *  isZero\r\n *  lessThan                  lt\r\n *  lessThanOrEqualTo         lte\r\n *  logarithm                 log\r\n *  [maximum]                 [max]\r\n *  [minimum]                 [min]\r\n *  minus                     sub\r\n *  modulo                    mod\r\n *  naturalExponential        exp\r\n *  naturalLogarithm          ln\r\n *  negated                   neg\r\n *  plus                      add\r\n *  precision                 sd\r\n *  round\r\n *  sine                      sin\r\n *  squareRoot                sqrt\r\n *  tangent                   tan\r\n *  times                     mul\r\n *  toBinary\r\n *  toDecimalPlaces           toDP\r\n *  toExponential\r\n *  toFixed\r\n *  toFraction\r\n *  toHexadecimal             toHex\r\n *  toNearest\r\n *  toNumber\r\n *  toOctal\r\n *  toPower                   pow\r\n *  toPrecision\r\n *  toSignificantDigits       toSD\r\n *  toString\r\n *  truncated                 trunc\r\n *  valueOf                   toJSON\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the absolute value of this Decimal.\r\n *\r\n */\r\nP.absoluteValue = P.abs = function () {\r\n  var x = new this.constructor(this);\r\n  if (x.s < 0) x.s = 1;\r\n  return finalise(x);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of positive Infinity.\r\n *\r\n */\r\nP.ceil = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 2);\r\n};\r\n\r\n\r\n/*\r\n * Return\r\n *   1    if the value of this Decimal is greater than the value of `y`,\r\n *  -1    if the value of this Decimal is less than the value of `y`,\r\n *   0    if they have the same value,\r\n *   NaN  if the value of either Decimal is NaN.\r\n *\r\n */\r\nP.comparedTo = P.cmp = function (y) {\r\n  var i, j, xdL, ydL,\r\n    x = this,\r\n    xd = x.d,\r\n    yd = (y = new x.constructor(y)).d,\r\n    xs = x.s,\r\n    ys = y.s;\r\n\r\n  // Either NaN or Infinity?\r\n  if (!xd || !yd) {\r\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n  }\r\n\r\n  // Either zero?\r\n  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n  // Signs differ?\r\n  if (xs !== ys) return xs;\r\n\r\n  // Compare exponents.\r\n  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n  xdL = xd.length;\r\n  ydL = yd.length;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n  }\r\n\r\n  // Compare lengths.\r\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * cos(0)         = 1\r\n * cos(-0)        = 1\r\n * cos(Infinity)  = NaN\r\n * cos(-Infinity) = NaN\r\n * cos(NaN)       = NaN\r\n *\r\n */\r\nP.cosine = P.cos = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.d) return new Ctor(NaN);\r\n\r\n  // cos(0) = cos(-0) = 1\r\n  if (!x.d[0]) return new Ctor(1);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n  Ctor.rounding = 1;\r\n\r\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n *\r\n * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n *  cbrt(0)  =  0\r\n *  cbrt(-0) = -0\r\n *  cbrt(1)  =  1\r\n *  cbrt(-1) = -1\r\n *  cbrt(N)  =  N\r\n *  cbrt(-I) = -I\r\n *  cbrt(I)  =  I\r\n *\r\n * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n *\r\n */\r\nP.cubeRoot = P.cbrt = function () {\r\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n  external = false;\r\n\r\n  // Initial estimate.\r\n  s = x.s * Math.pow(x.s * x, 1 / 3);\r\n\r\n   // Math.cbrt underflow/overflow?\r\n   // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n  if (!s || Math.abs(s) == 1 / 0) {\r\n    n = digitsToString(x.d);\r\n    e = x.e;\r\n\r\n    // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n    s = Math.pow(n, 1 / 3);\r\n\r\n    // Rarely, e may be one less than the result exponent value.\r\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n    if (s == 1 / 0) {\r\n      n = '5e' + e;\r\n    } else {\r\n      n = s.toExponential();\r\n      n = n.slice(0, n.indexOf('e') + 1) + e;\r\n    }\r\n\r\n    r = new Ctor(n);\r\n    r.s = x.s;\r\n  } else {\r\n    r = new Ctor(s.toString());\r\n  }\r\n\r\n  sd = (e = Ctor.precision) + 3;\r\n\r\n  // Halley's method.\r\n  // TODO? Compare Newton's method.\r\n  for (;;) {\r\n    t = r;\r\n    t3 = t.times(t).times(t);\r\n    t3plusx = t3.plus(x);\r\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n    // TODO? Replace with for-loop and checkRoundingDigits.\r\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n      n = n.slice(sd - 3, sd + 1);\r\n\r\n      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n      // , i.e. approaching a rounding boundary, continue the iteration.\r\n      if (n == '9999' || !rep && n == '4999') {\r\n\r\n        // On the first iteration only, check to see if rounding up gives the exact result as the\r\n        // nines may infinitely repeat.\r\n        if (!rep) {\r\n          finalise(t, e + 1, 0);\r\n\r\n          if (t.times(t).times(t).eq(x)) {\r\n            r = t;\r\n            break;\r\n          }\r\n        }\r\n\r\n        sd += 4;\r\n        rep = 1;\r\n      } else {\r\n\r\n        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n        // If not, then there are further digits and m will be truthy.\r\n        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n          // Truncate to the first rounding digit.\r\n          finalise(r, e + 1, 1);\r\n          m = !r.times(r).times(r).eq(x);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, e, Ctor.rounding, m);\r\n};\r\n\r\n\r\n/*\r\n * Return the number of decimal places of the value of this Decimal.\r\n *\r\n */\r\nP.decimalPlaces = P.dp = function () {\r\n  var w,\r\n    d = this.d,\r\n    n = NaN;\r\n\r\n  if (d) {\r\n    w = d.length - 1;\r\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last word.\r\n    w = d[w];\r\n    if (w) for (; w % 10 == 0; w /= 10) n--;\r\n    if (n < 0) n = 0;\r\n  }\r\n\r\n  return n;\r\n};\r\n\r\n\r\n/*\r\n *  n / 0 = I\r\n *  n / N = N\r\n *  n / I = 0\r\n *  0 / n = 0\r\n *  0 / 0 = N\r\n *  0 / N = N\r\n *  0 / I = 0\r\n *  N / n = N\r\n *  N / 0 = N\r\n *  N / N = N\r\n *  N / I = N\r\n *  I / n = I\r\n *  I / 0 = I\r\n *  I / N = N\r\n *  I / I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.dividedBy = P.div = function (y) {\r\n  return divide(this, new this.constructor(y));\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.dividedToIntegerBy = P.divToInt = function (y) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n *\r\n */\r\nP.equals = P.eq = function (y) {\r\n  return this.cmp(y) === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of negative Infinity.\r\n *\r\n */\r\nP.floor = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 3);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n * false.\r\n *\r\n */\r\nP.greaterThan = P.gt = function (y) {\r\n  return this.cmp(y) > 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n * otherwise return false.\r\n *\r\n */\r\nP.greaterThanOrEqualTo = P.gte = function (y) {\r\n  var k = this.cmp(y);\r\n  return k == 1 || k === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [1, Infinity]\r\n *\r\n * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n *\r\n * cosh(0)         = 1\r\n * cosh(-0)        = 1\r\n * cosh(Infinity)  = Infinity\r\n * cosh(-Infinity) = Infinity\r\n * cosh(NaN)       = NaN\r\n *\r\n *  x        time taken (ms)   result\r\n * 1000      9                 9.8503555700852349694e+433\r\n * 10000     25                4.4034091128314607936e+4342\r\n * 100000    171               1.4033316802130615897e+43429\r\n * 1000000   3817              1.5166076984010437725e+434294\r\n * 10000000  abandoned after 2 minute wait\r\n *\r\n * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n *\r\n */\r\nP.hyperbolicCosine = P.cosh = function () {\r\n  var k, n, pr, rm, len,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    one = new Ctor(1);\r\n\r\n  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n  if (x.isZero()) return one;\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  len = x.d.length;\r\n\r\n  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  // TODO? Estimation reused from cosine() and may not be optimal here.\r\n  if (len < 32) {\r\n    k = Math.ceil(len / 3);\r\n    n = Math.pow(4, -k).toString();\r\n  } else {\r\n    k = 16;\r\n    n = '2.3283064365386962890625e-10';\r\n  }\r\n\r\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n  // Reverse argument reduction\r\n  var cosh2_x,\r\n    i = k,\r\n    d8 = new Ctor(8);\r\n  for (; i--;) {\r\n    cosh2_x = x.times(x);\r\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n  }\r\n\r\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n *\r\n * sinh(0)         = 0\r\n * sinh(-0)        = -0\r\n * sinh(Infinity)  = Infinity\r\n * sinh(-Infinity) = -Infinity\r\n * sinh(NaN)       = NaN\r\n *\r\n * x        time taken (ms)\r\n * 10       2 ms\r\n * 100      5 ms\r\n * 1000     14 ms\r\n * 10000    82 ms\r\n * 100000   886 ms            1.4033316802130615897e+43429\r\n * 200000   2613 ms\r\n * 300000   5407 ms\r\n * 400000   8824 ms\r\n * 500000   13026 ms          8.7080643612718084129e+217146\r\n * 1000000  48543 ms\r\n *\r\n * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n *\r\n */\r\nP.hyperbolicSine = P.sinh = function () {\r\n  var k, pr, rm, len,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  len = x.d.length;\r\n\r\n  if (len < 3) {\r\n    x = taylorSeries(Ctor, 2, x, x, true);\r\n  } else {\r\n\r\n    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n    // 3 multiplications and 1 addition\r\n\r\n    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n    // 4 multiplications and 2 additions\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(Math.pow(5, -k));\r\n\r\n    x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n    // Reverse argument reduction\r\n    var sinh2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sinh2_x = x.times(x);\r\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n    }\r\n  }\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * tanh(x) = sinh(x) / cosh(x)\r\n *\r\n * tanh(0)         = 0\r\n * tanh(-0)        = -0\r\n * tanh(Infinity)  = 1\r\n * tanh(-Infinity) = -1\r\n * tanh(NaN)       = NaN\r\n *\r\n */\r\nP.hyperbolicTangent = P.tanh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(x.s);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 7;\r\n  Ctor.rounding = 1;\r\n\r\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n * this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [0, pi]\r\n *\r\n * acos(x) = pi/2 - asin(x)\r\n *\r\n * acos(0)       = pi/2\r\n * acos(-0)      = pi/2\r\n * acos(1)       = 0\r\n * acos(-1)      = pi\r\n * acos(1/2)     = pi/3\r\n * acos(-1/2)    = 2*pi/3\r\n * acos(|x| > 1) = NaN\r\n * acos(NaN)     = NaN\r\n *\r\n */\r\nP.inverseCosine = P.acos = function () {\r\n  var halfPi,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    k = x.abs().cmp(1),\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding;\r\n\r\n  if (k !== -1) {\r\n    return k === 0\r\n      // |x| is 1\r\n      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n      // |x| > 1 or x is NaN\r\n      : new Ctor(NaN);\r\n  }\r\n\r\n  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n  Ctor.precision = pr + 6;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.asin();\r\n  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return halfPi.minus(x);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [1, Infinity]\r\n * Range: [0, Infinity]\r\n *\r\n * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n *\r\n * acosh(x < 1)     = NaN\r\n * acosh(NaN)       = NaN\r\n * acosh(Infinity)  = Infinity\r\n * acosh(-Infinity) = NaN\r\n * acosh(0)         = NaN\r\n * acosh(-0)        = NaN\r\n * acosh(1)         = 0\r\n * acosh(-1)        = NaN\r\n *\r\n */\r\nP.inverseHyperbolicCosine = P.acosh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n  if (!x.isFinite()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  external = false;\r\n\r\n  x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n  external = true;\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.ln();\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n *\r\n * asinh(NaN)       = NaN\r\n * asinh(Infinity)  = Infinity\r\n * asinh(-Infinity) = -Infinity\r\n * asinh(0)         = 0\r\n * asinh(-0)        = -0\r\n *\r\n */\r\nP.inverseHyperbolicSine = P.asinh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n  Ctor.rounding = 1;\r\n  external = false;\r\n\r\n  x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n  external = true;\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.ln();\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n *\r\n * atanh(|x| > 1)   = NaN\r\n * atanh(NaN)       = NaN\r\n * atanh(Infinity)  = NaN\r\n * atanh(-Infinity) = NaN\r\n * atanh(0)         = 0\r\n * atanh(-0)        = -0\r\n * atanh(1)         = Infinity\r\n * atanh(-1)        = -Infinity\r\n *\r\n */\r\nP.inverseHyperbolicTangent = P.atanh = function () {\r\n  var pr, rm, wpr, xsd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  xsd = x.sd();\r\n\r\n  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n  Ctor.precision = wpr = xsd - x.e;\r\n\r\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n  Ctor.precision = pr + 4;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.ln();\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.times(0.5);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n *\r\n * asin(0)       = 0\r\n * asin(-0)      = -0\r\n * asin(1/2)     = pi/6\r\n * asin(-1/2)    = -pi/6\r\n * asin(1)       = pi/2\r\n * asin(-1)      = -pi/2\r\n * asin(|x| > 1) = NaN\r\n * asin(NaN)     = NaN\r\n *\r\n * TODO? Compare performance of Taylor series.\r\n *\r\n */\r\nP.inverseSine = P.asin = function () {\r\n  var halfPi, k,\r\n    pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  k = x.abs().cmp(1);\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  if (k !== -1) {\r\n\r\n    // |x| is 1\r\n    if (k === 0) {\r\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n      halfPi.s = x.s;\r\n      return halfPi;\r\n    }\r\n\r\n    // |x| > 1 or x is NaN\r\n    return new Ctor(NaN);\r\n  }\r\n\r\n  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n  Ctor.precision = pr + 6;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.times(2);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n *\r\n * atan(0)         = 0\r\n * atan(-0)        = -0\r\n * atan(1)         = pi/4\r\n * atan(-1)        = -pi/4\r\n * atan(Infinity)  = pi/2\r\n * atan(-Infinity) = -pi/2\r\n * atan(NaN)       = NaN\r\n *\r\n */\r\nP.inverseTangent = P.atan = function () {\r\n  var i, j, k, n, px, t, r, wpr, x2,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding;\r\n\r\n  if (!x.isFinite()) {\r\n    if (!x.s) return new Ctor(NaN);\r\n    if (pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n  } else if (x.isZero()) {\r\n    return new Ctor(x);\r\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n    r.s = x.s;\r\n    return r;\r\n  }\r\n\r\n  Ctor.precision = wpr = pr + 10;\r\n  Ctor.rounding = 1;\r\n\r\n  // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n  // Argument reduction\r\n  // Ensure |x| < 0.42\r\n  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n  external = false;\r\n\r\n  j = Math.ceil(wpr / LOG_BASE);\r\n  n = 1;\r\n  x2 = x.times(x);\r\n  r = new Ctor(x);\r\n  px = x;\r\n\r\n  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n  for (; i !== -1;) {\r\n    px = px.times(x2);\r\n    t = r.minus(px.div(n += 2));\r\n\r\n    px = px.times(x2);\r\n    r = t.plus(px.div(n += 2));\r\n\r\n    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n  }\r\n\r\n  if (k) r = r.times(2 << (k - 1));\r\n\r\n  external = true;\r\n\r\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n *\r\n */\r\nP.isFinite = function () {\r\n  return !!this.d;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is an integer, otherwise return false.\r\n *\r\n */\r\nP.isInteger = P.isInt = function () {\r\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is NaN, otherwise return false.\r\n *\r\n */\r\nP.isNaN = function () {\r\n  return !this.s;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is negative, otherwise return false.\r\n *\r\n */\r\nP.isNegative = P.isNeg = function () {\r\n  return this.s < 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is positive, otherwise return false.\r\n *\r\n */\r\nP.isPositive = P.isPos = function () {\r\n  return this.s > 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n *\r\n */\r\nP.isZero = function () {\r\n  return !!this.d && this.d[0] === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n *\r\n */\r\nP.lessThan = P.lt = function (y) {\r\n  return this.cmp(y) < 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n *\r\n */\r\nP.lessThanOrEqualTo = P.lte = function (y) {\r\n  return this.cmp(y) < 1;\r\n};\r\n\r\n\r\n/*\r\n * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * If no base is specified, return log[10](arg).\r\n *\r\n * log[base](arg) = ln(arg) / ln(base)\r\n *\r\n * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n * otherwise:\r\n *\r\n * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n *\r\n * log[-b](a)       = NaN\r\n * log[0](a)        = NaN\r\n * log[1](a)        = NaN\r\n * log[NaN](a)      = NaN\r\n * log[Infinity](a) = NaN\r\n * log[b](0)        = -Infinity\r\n * log[b](-0)       = -Infinity\r\n * log[b](-a)       = NaN\r\n * log[b](1)        = 0\r\n * log[b](Infinity) = Infinity\r\n * log[b](NaN)      = NaN\r\n *\r\n * [base] {number|string|Decimal} The base of the logarithm.\r\n *\r\n */\r\nP.logarithm = P.log = function (base) {\r\n  var isBase10, d, denominator, k, inf, num, sd, r,\r\n    arg = this,\r\n    Ctor = arg.constructor,\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding,\r\n    guard = 5;\r\n\r\n  // Default base is 10.\r\n  if (base == null) {\r\n    base = new Ctor(10);\r\n    isBase10 = true;\r\n  } else {\r\n    base = new Ctor(base);\r\n    d = base.d;\r\n\r\n    // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n    isBase10 = base.eq(10);\r\n  }\r\n\r\n  d = arg.d;\r\n\r\n  // Is arg negative, non-finite, 0 or 1?\r\n  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n  }\r\n\r\n  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n  // integer power of 10.\r\n  if (isBase10) {\r\n    if (d.length > 1) {\r\n      inf = true;\r\n    } else {\r\n      for (k = d[0]; k % 10 === 0;) k /= 10;\r\n      inf = k !== 1;\r\n    }\r\n  }\r\n\r\n  external = false;\r\n  sd = pr + guard;\r\n  num = naturalLogarithm(arg, sd);\r\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n  // The result will have 5 rounding digits.\r\n  r = divide(num, denominator, sd, 1);\r\n\r\n  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n  // calculate 10 further digits.\r\n  //\r\n  // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n  // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n  // further digits, the last 14 are nines, round up and assume the result is exact.\r\n  // Also assume the result is exact if the last 14 are zero.\r\n  //\r\n  // Example of a result that will be incorrectly rounded:\r\n  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n  // place is still 2.6.\r\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n    do {\r\n      sd += 10;\r\n      num = naturalLogarithm(arg, sd);\r\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n      r = divide(num, denominator, sd, 1);\r\n\r\n      if (!inf) {\r\n\r\n        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n\r\n        break;\r\n      }\r\n    } while (checkRoundingDigits(r.d, k += 10, rm));\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, pr, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.max = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'lt');\r\n};\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.min = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'gt');\r\n};\r\n */\r\n\r\n\r\n/*\r\n *  n - 0 = n\r\n *  n - N = N\r\n *  n - I = -I\r\n *  0 - n = -n\r\n *  0 - 0 = 0\r\n *  0 - N = N\r\n *  0 - I = -I\r\n *  N - n = N\r\n *  N - 0 = N\r\n *  N - N = N\r\n *  N - I = N\r\n *  I - n = I\r\n *  I - 0 = I\r\n *  I - N = N\r\n *  I - I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.minus = P.sub = function (y) {\r\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // If either is not finite...\r\n  if (!x.d || !y.d) {\r\n\r\n    // Return NaN if either is NaN.\r\n    if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n    // Return y negated if x is finite and y is Infinity.\r\n    else if (x.d) y.s = -y.s;\r\n\r\n    // Return x if y is finite and x is Infinity.\r\n    // Return x if both are Infinity with different signs.\r\n    // Return NaN if both are Infinity with the same sign.\r\n    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n    return y;\r\n  }\r\n\r\n  // If signs differ...\r\n  if (x.s != y.s) {\r\n    y.s = -y.s;\r\n    return x.plus(y);\r\n  }\r\n\r\n  xd = x.d;\r\n  yd = y.d;\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  // If either is zero...\r\n  if (!xd[0] || !yd[0]) {\r\n\r\n    // Return y negated if x is zero and y is non-zero.\r\n    if (yd[0]) y.s = -y.s;\r\n\r\n    // Return x if y is zero and x is non-zero.\r\n    else if (xd[0]) y = new Ctor(x);\r\n\r\n    // Return zero if both are zero.\r\n    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n    else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  }\r\n\r\n  // x and y are finite, non-zero numbers with the same sign.\r\n\r\n  // Calculate base 1e7 exponents.\r\n  e = mathfloor(y.e / LOG_BASE);\r\n  xe = mathfloor(x.e / LOG_BASE);\r\n\r\n  xd = xd.slice();\r\n  k = xe - e;\r\n\r\n  // If base 1e7 exponents differ...\r\n  if (k) {\r\n    xLTy = k < 0;\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      k = -k;\r\n      len = yd.length;\r\n    } else {\r\n      d = yd;\r\n      e = xe;\r\n      len = xd.length;\r\n    }\r\n\r\n    // Numbers with massively different exponents would result in a very high number of\r\n    // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n    if (k > i) {\r\n      k = i;\r\n      d.length = 1;\r\n    }\r\n\r\n    // Prepend zeros to equalise exponents.\r\n    d.reverse();\r\n    for (i = k; i--;) d.push(0);\r\n    d.reverse();\r\n\r\n  // Base 1e7 exponents equal.\r\n  } else {\r\n\r\n    // Check digits to determine which is the bigger number.\r\n\r\n    i = xd.length;\r\n    len = yd.length;\r\n    xLTy = i < len;\r\n    if (xLTy) len = i;\r\n\r\n    for (i = 0; i < len; i++) {\r\n      if (xd[i] != yd[i]) {\r\n        xLTy = xd[i] < yd[i];\r\n        break;\r\n      }\r\n    }\r\n\r\n    k = 0;\r\n  }\r\n\r\n  if (xLTy) {\r\n    d = xd;\r\n    xd = yd;\r\n    yd = d;\r\n    y.s = -y.s;\r\n  }\r\n\r\n  len = xd.length;\r\n\r\n  // Append zeros to `xd` if shorter.\r\n  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n  // Subtract yd from xd.\r\n  for (i = yd.length; i > k;) {\r\n\r\n    if (xd[--i] < yd[i]) {\r\n      for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n      --xd[j];\r\n      xd[i] += BASE;\r\n    }\r\n\r\n    xd[i] -= yd[i];\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  for (; xd[--len] === 0;) xd.pop();\r\n\r\n  // Remove leading zeros and adjust exponent accordingly.\r\n  for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n  // Zero?\r\n  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n  y.d = xd;\r\n  y.e = getBase10Exponent(xd, e);\r\n\r\n  return external ? finalise(y, pr, rm) : y;\r\n};\r\n\r\n\r\n/*\r\n *   n % 0 =  N\r\n *   n % N =  N\r\n *   n % I =  n\r\n *   0 % n =  0\r\n *  -0 % n = -0\r\n *   0 % 0 =  N\r\n *   0 % N =  N\r\n *   0 % I =  0\r\n *   N % n =  N\r\n *   N % 0 =  N\r\n *   N % N =  N\r\n *   N % I =  N\r\n *   I % n =  N\r\n *   I % 0 =  N\r\n *   I % N =  N\r\n *   I % I =  N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * The result depends on the modulo mode.\r\n *\r\n */\r\nP.modulo = P.mod = function (y) {\r\n  var q,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // Return NaN if x is Infinity or NaN, or y is NaN or 0.\r\n  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n  // Return x if y is Infinity or x is 0.\r\n  if (!y.d || x.d && !x.d[0]) {\r\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n  }\r\n\r\n  // Prevent rounding of intermediate calculations.\r\n  external = false;\r\n\r\n  if (Ctor.modulo == 9) {\r\n\r\n    // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n    // result = x - q * y    where  0 <= result < abs(y)\r\n    q = divide(x, y.abs(), 0, 3, 1);\r\n    q.s *= y.s;\r\n  } else {\r\n    q = divide(x, y, 0, Ctor.modulo, 1);\r\n  }\r\n\r\n  q = q.times(y);\r\n\r\n  external = true;\r\n\r\n  return x.minus(q);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.naturalExponential = P.exp = function () {\r\n  return naturalExponential(this);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.naturalLogarithm = P.ln = function () {\r\n  return naturalLogarithm(this);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n * -1.\r\n *\r\n */\r\nP.negated = P.neg = function () {\r\n  var x = new this.constructor(this);\r\n  x.s = -x.s;\r\n  return finalise(x);\r\n};\r\n\r\n\r\n/*\r\n *  n + 0 = n\r\n *  n + N = N\r\n *  n + I = I\r\n *  0 + n = n\r\n *  0 + 0 = 0\r\n *  0 + N = N\r\n *  0 + I = I\r\n *  N + n = N\r\n *  N + 0 = N\r\n *  N + N = N\r\n *  N + I = N\r\n *  I + n = I\r\n *  I + 0 = I\r\n *  I + N = N\r\n *  I + I = I\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.plus = P.add = function (y) {\r\n  var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // If either is not finite...\r\n  if (!x.d || !y.d) {\r\n\r\n    // Return NaN if either is NaN.\r\n    if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n    // Return x if y is finite and x is Infinity.\r\n    // Return x if both are Infinity with the same sign.\r\n    // Return NaN if both are Infinity with different signs.\r\n    // Return y if x is finite and y is Infinity.\r\n    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n    return y;\r\n  }\r\n\r\n   // If signs differ...\r\n  if (x.s != y.s) {\r\n    y.s = -y.s;\r\n    return x.minus(y);\r\n  }\r\n\r\n  xd = x.d;\r\n  yd = y.d;\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  // If either is zero...\r\n  if (!xd[0] || !yd[0]) {\r\n\r\n    // Return x if y is zero.\r\n    // Return y if y is non-zero.\r\n    if (!yd[0]) y = new Ctor(x);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  }\r\n\r\n  // x and y are finite, non-zero numbers with the same sign.\r\n\r\n  // Calculate base 1e7 exponents.\r\n  k = mathfloor(x.e / LOG_BASE);\r\n  e = mathfloor(y.e / LOG_BASE);\r\n\r\n  xd = xd.slice();\r\n  i = k - e;\r\n\r\n  // If base 1e7 exponents differ...\r\n  if (i) {\r\n\r\n    if (i < 0) {\r\n      d = xd;\r\n      i = -i;\r\n      len = yd.length;\r\n    } else {\r\n      d = yd;\r\n      e = k;\r\n      len = xd.length;\r\n    }\r\n\r\n    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n    k = Math.ceil(pr / LOG_BASE);\r\n    len = k > len ? k + 1 : len + 1;\r\n\r\n    if (i > len) {\r\n      i = len;\r\n      d.length = 1;\r\n    }\r\n\r\n    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n    d.reverse();\r\n    for (; i--;) d.push(0);\r\n    d.reverse();\r\n  }\r\n\r\n  len = xd.length;\r\n  i = yd.length;\r\n\r\n  // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n  if (len - i < 0) {\r\n    i = len;\r\n    d = yd;\r\n    yd = xd;\r\n    xd = d;\r\n  }\r\n\r\n  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n  for (carry = 0; i;) {\r\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n    xd[i] %= BASE;\r\n  }\r\n\r\n  if (carry) {\r\n    xd.unshift(carry);\r\n    ++e;\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n  for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n  y.d = xd;\r\n  y.e = getBase10Exponent(xd, e);\r\n\r\n  return external ? finalise(y, pr, rm) : y;\r\n};\r\n\r\n\r\n/*\r\n * Return the number of significant digits of the value of this Decimal.\r\n *\r\n * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n *\r\n */\r\nP.precision = P.sd = function (z) {\r\n  var k,\r\n    x = this;\r\n\r\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n  if (x.d) {\r\n    k = getPrecision(x.d);\r\n    if (z && x.e + 1 > k) k = x.e + 1;\r\n  } else {\r\n    k = NaN;\r\n  }\r\n\r\n  return k;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n * rounding mode `rounding`.\r\n *\r\n */\r\nP.round = function () {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n *\r\n * sin(0)         = 0\r\n * sin(-0)        = -0\r\n * sin(Infinity)  = NaN\r\n * sin(-Infinity) = NaN\r\n * sin(NaN)       = NaN\r\n *\r\n */\r\nP.sine = P.sin = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n  Ctor.rounding = 1;\r\n\r\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n *  sqrt(-n) =  N\r\n *  sqrt(N)  =  N\r\n *  sqrt(-I) =  N\r\n *  sqrt(I)  =  I\r\n *  sqrt(0)  =  0\r\n *  sqrt(-0) = -0\r\n *\r\n */\r\nP.squareRoot = P.sqrt = function () {\r\n  var m, n, sd, r, rep, t,\r\n    x = this,\r\n    d = x.d,\r\n    e = x.e,\r\n    s = x.s,\r\n    Ctor = x.constructor;\r\n\r\n  // Negative/NaN/Infinity/zero?\r\n  if (s !== 1 || !d || !d[0]) {\r\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n  }\r\n\r\n  external = false;\r\n\r\n  // Initial estimate.\r\n  s = Math.sqrt(+x);\r\n\r\n  // Math.sqrt underflow/overflow?\r\n  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n  if (s == 0 || s == 1 / 0) {\r\n    n = digitsToString(d);\r\n\r\n    if ((n.length + e) % 2 == 0) n += '0';\r\n    s = Math.sqrt(n);\r\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n    if (s == 1 / 0) {\r\n      n = '1e' + e;\r\n    } else {\r\n      n = s.toExponential();\r\n      n = n.slice(0, n.indexOf('e') + 1) + e;\r\n    }\r\n\r\n    r = new Ctor(n);\r\n  } else {\r\n    r = new Ctor(s.toString());\r\n  }\r\n\r\n  sd = (e = Ctor.precision) + 3;\r\n\r\n  // Newton-Raphson iteration.\r\n  for (;;) {\r\n    t = r;\r\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n    // TODO? Replace with for-loop and checkRoundingDigits.\r\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n      n = n.slice(sd - 3, sd + 1);\r\n\r\n      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n      // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n      if (n == '9999' || !rep && n == '4999') {\r\n\r\n        // On the first iteration only, check to see if rounding up gives the exact result as the\r\n        // nines may infinitely repeat.\r\n        if (!rep) {\r\n          finalise(t, e + 1, 0);\r\n\r\n          if (t.times(t).eq(x)) {\r\n            r = t;\r\n            break;\r\n          }\r\n        }\r\n\r\n        sd += 4;\r\n        rep = 1;\r\n      } else {\r\n\r\n        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n        // If not, then there are further digits and m will be truthy.\r\n        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n          // Truncate to the first rounding digit.\r\n          finalise(r, e + 1, 1);\r\n          m = !r.times(r).eq(x);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, e, Ctor.rounding, m);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * tan(0)         = 0\r\n * tan(-0)        = -0\r\n * tan(Infinity)  = NaN\r\n * tan(-Infinity) = NaN\r\n * tan(NaN)       = NaN\r\n *\r\n */\r\nP.tangent = P.tan = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 10;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.sin();\r\n  x.s = 1;\r\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n *  n * 0 = 0\r\n *  n * N = N\r\n *  n * I = I\r\n *  0 * n = 0\r\n *  0 * 0 = 0\r\n *  0 * N = N\r\n *  0 * I = N\r\n *  N * n = N\r\n *  N * 0 = N\r\n *  N * N = N\r\n *  N * I = N\r\n *  I * n = I\r\n *  I * 0 = N\r\n *  I * N = N\r\n *  I * I = I\r\n *\r\n * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.times = P.mul = function (y) {\r\n  var carry, e, i, k, r, rL, t, xdL, ydL,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    xd = x.d,\r\n    yd = (y = new Ctor(y)).d;\r\n\r\n  y.s *= x.s;\r\n\r\n   // If either is NaN, Infinity or 0...\r\n  if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n      // Return NaN if either is NaN.\r\n      // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.\r\n      ? NaN\r\n\r\n      // Return Infinity if either is Infinity.\r\n      // Return 0 if either is 0.\r\n      : !xd || !yd ? y.s / 0 : y.s * 0);\r\n  }\r\n\r\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n  xdL = xd.length;\r\n  ydL = yd.length;\r\n\r\n  // Ensure xd points to the longer array.\r\n  if (xdL < ydL) {\r\n    r = xd;\r\n    xd = yd;\r\n    yd = r;\r\n    rL = xdL;\r\n    xdL = ydL;\r\n    ydL = rL;\r\n  }\r\n\r\n  // Initialise the result array with zeros.\r\n  r = [];\r\n  rL = xdL + ydL;\r\n  for (i = rL; i--;) r.push(0);\r\n\r\n  // Multiply!\r\n  for (i = ydL; --i >= 0;) {\r\n    carry = 0;\r\n    for (k = xdL + i; k > i;) {\r\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n      r[k--] = t % BASE | 0;\r\n      carry = t / BASE | 0;\r\n    }\r\n\r\n    r[k] = (r[k] + carry) % BASE | 0;\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  for (; !r[--rL];) r.pop();\r\n\r\n  if (carry) ++e;\r\n  else r.shift();\r\n\r\n  y.d = r;\r\n  y.e = getBase10Exponent(r, e);\r\n\r\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toBinary = function (sd, rm) {\r\n  return toStringBinary(this, 2, sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n *\r\n * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  x = new Ctor(x);\r\n  if (dp === void 0) return x;\r\n\r\n  checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n  if (rm === void 0) rm = Ctor.rounding;\r\n  else checkInt32(rm, 0, 8);\r\n\r\n  return finalise(x, dp + x.e + 1, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in exponential notation rounded to\r\n * `dp` fixed decimal places using rounding mode `rounding`.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toExponential = function (dp, rm) {\r\n  var str,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (dp === void 0) {\r\n    str = finiteToString(x, true);\r\n  } else {\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    x = finalise(new Ctor(x), dp + 1, rm);\r\n    str = finiteToString(x, true, dp + 1);\r\n  }\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n * omitted.\r\n *\r\n * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n * (-0).toFixed(3) is '0.000'.\r\n * (-0.5).toFixed(0) is '-0'.\r\n *\r\n */\r\nP.toFixed = function (dp, rm) {\r\n  var str, y,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (dp === void 0) {\r\n    str = finiteToString(x);\r\n  } else {\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n    str = finiteToString(y, false, dp + y.e + 1);\r\n  }\r\n\r\n  // To determine whether to add the minus sign look at the value before it was rounded,\r\n  // i.e. look at `x` rather than `y`.\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n * numerator and an integer denominator.\r\n *\r\n * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n * value necessary to represent the number exactly.\r\n *\r\n * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n *\r\n */\r\nP.toFraction = function (maxD) {\r\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n    x = this,\r\n    xd = x.d,\r\n    Ctor = x.constructor;\r\n\r\n  if (!xd) return new Ctor(x);\r\n\r\n  n1 = d0 = new Ctor(1);\r\n  d1 = n0 = new Ctor(0);\r\n\r\n  d = new Ctor(d1);\r\n  e = d.e = getPrecision(xd) - x.e - 1;\r\n  k = e % LOG_BASE;\r\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n  if (maxD == null) {\r\n\r\n    // d is 10**e, the minimum max-denominator needed.\r\n    maxD = e > 0 ? d : n1;\r\n  } else {\r\n    n = new Ctor(maxD);\r\n    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n    maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n  }\r\n\r\n  external = false;\r\n  n = new Ctor(digitsToString(xd));\r\n  pr = Ctor.precision;\r\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n  for (;;)  {\r\n    q = divide(n, d, 0, 1, 1);\r\n    d2 = d0.plus(q.times(d1));\r\n    if (d2.cmp(maxD) == 1) break;\r\n    d0 = d1;\r\n    d1 = d2;\r\n    d2 = n1;\r\n    n1 = n0.plus(q.times(d2));\r\n    n0 = d2;\r\n    d2 = d;\r\n    d = n.minus(q.times(d2));\r\n    n = d2;\r\n  }\r\n\r\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n  n0 = n0.plus(d2.times(n1));\r\n  d0 = d0.plus(d2.times(d1));\r\n  n0.s = n1.s = x.s;\r\n\r\n  // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n      ? [n1, d1] : [n0, d0];\r\n\r\n  Ctor.precision = pr;\r\n  external = true;\r\n\r\n  return r;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toHexadecimal = P.toHex = function (sd, rm) {\r\n  return toStringBinary(this, 16, sd, rm);\r\n};\r\n\r\n\r\n\r\n/*\r\n * Returns a new Decimal whose value is the nearest multiple of the magnitude of `y` to the value\r\n * of this Decimal.\r\n *\r\n * If the value of this Decimal is equidistant from two multiples of `y`, the rounding mode `rm`,\r\n * or `Decimal.rounding` if `rm` is omitted, determines the direction of the nearest multiple.\r\n *\r\n * In the context of this method, rounding mode 4 (ROUND_HALF_UP) is the same as rounding mode 0\r\n * (ROUND_UP), and so on.\r\n *\r\n * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n * or `y` is NaN, in which case the return value will be also be NaN.\r\n *\r\n * The return value is not affected by the value of `precision`.\r\n *\r\n * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toNearest() rounding mode not an integer: {rm}'\r\n * 'toNearest() rounding mode out of range: {rm}'\r\n *\r\n */\r\nP.toNearest = function (y, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  x = new Ctor(x);\r\n\r\n  if (y == null) {\r\n\r\n    // If x is not finite, return x.\r\n    if (!x.d) return x;\r\n\r\n    y = new Ctor(1);\r\n    rm = Ctor.rounding;\r\n  } else {\r\n    y = new Ctor(y);\r\n    if (rm !== void 0) checkInt32(rm, 0, 8);\r\n\r\n    // If x is not finite, return x if y is not NaN, else NaN.\r\n    if (!x.d) return y.s ? x : y;\r\n\r\n    // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n    if (!y.d) {\r\n      if (y.s) y.s = x.s;\r\n      return y;\r\n    }\r\n  }\r\n\r\n  // If y is not zero, calculate the nearest multiple of y to x.\r\n  if (y.d[0]) {\r\n    external = false;\r\n    if (rm < 4) rm = [4, 5, 7, 8][rm];\r\n    x = divide(x, y, 0, rm, 1).times(y);\r\n    external = true;\r\n    finalise(x);\r\n\r\n  // If y is zero, return zero with the sign of x.\r\n  } else {\r\n    y.s = x.s;\r\n    x = y;\r\n  }\r\n\r\n  return x;\r\n};\r\n\r\n\r\n/*\r\n * Return the value of this Decimal converted to a number primitive.\r\n * Zero keeps its sign.\r\n *\r\n */\r\nP.toNumber = function () {\r\n  return +this;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toOctal = function (sd, rm) {\r\n  return toStringBinary(this, 8, sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n * to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * ECMAScript compliant.\r\n *\r\n *   pow(x, NaN)                           = NaN\r\n *   pow(x, 0)                            = 1\r\n\r\n *   pow(NaN, non-zero)                    = NaN\r\n *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n *   pow(abs(x) > 1, -Infinity)            = +0\r\n *   pow(abs(x) == 1, Infinity)           = NaN\r\n *   pow(abs(x) < 1, +Infinity)            = +0\r\n *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n *   pow(+Infinity, y > 0)                 = +Infinity\r\n *   pow(+Infinity, y < 0)                 = +0\r\n *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n *   pow(-Infinity, even integer > 0)      = +Infinity\r\n *   pow(-Infinity, odd integer < 0)       = -0\r\n *   pow(-Infinity, even integer < 0)      = +0\r\n *   pow(+0, y > 0)                        = +0\r\n *   pow(+0, y < 0)                        = +Infinity\r\n *   pow(-0, odd integer > 0)              = -0\r\n *   pow(-0, even integer > 0)             = +0\r\n *   pow(-0, odd integer < 0)              = -Infinity\r\n *   pow(-0, even integer < 0)             = +Infinity\r\n *   pow(finite x < 0, finite non-integer) = NaN\r\n *\r\n * For non-integer or very large exponents pow(x, y) is calculated using\r\n *\r\n *   x^y = exp(y*ln(x))\r\n *\r\n * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n * probability of an incorrectly rounded result\r\n * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n * i.e. 1 in 250,000,000,000,000\r\n *\r\n * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n *\r\n * y {number|string|Decimal} The power to which to raise this Decimal.\r\n *\r\n */\r\nP.toPower = P.pow = function (y) {\r\n  var e, k, pr, r, rm, sign, yIsInt,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    yn = +(y = new Ctor(y));\r\n\r\n  // Either Infinity, NaN or 0?\r\n  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return  new Ctor(mathpow(+x, yn));\r\n\r\n  x = new Ctor(x);\r\n\r\n  if (x.eq(1)) return x;\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n  e = mathfloor(y.e / LOG_BASE);\r\n  k = y.d.length - 1;\r\n  yIsInt = e >= k;\r\n  sign = x.s;\r\n\r\n  if (!yIsInt) {\r\n    if (sign < 0) return new Ctor(NaN);\r\n\r\n  // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n  } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n    r = intPow(Ctor, x, k, pr);\r\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n  }\r\n\r\n  // Result is negative if x is negative and the last digit of integer y is odd.\r\n  sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;\r\n\r\n  // Estimate result exponent.\r\n  // x^y = 10^e,  where e = y * log10(x)\r\n  // log10(x) = log10(x_significand) + x_exponent\r\n  // log10(x_significand) = ln(x_significand) / ln(10)\r\n  k = mathpow(+x, yn);\r\n  e = k == 0 || !isFinite(k)\r\n    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n    : new Ctor(k + '').e;\r\n\r\n  // Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n  // Overflow/underflow?\r\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? sign / 0 : 0);\r\n\r\n  external = false;\r\n  Ctor.rounding = x.s = 1;\r\n\r\n  // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n  // new Decimal(2.32456).pow('2087987436534566.46411')\r\n  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n  k = Math.min(12, (e + '').length);\r\n\r\n  // r = x^y = exp(y*ln(x))\r\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n  // Truncate to the required precision plus five rounding digits.\r\n  r = finalise(r, pr + 5, 1);\r\n\r\n  // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n  // the result.\r\n  if (checkRoundingDigits(r.d, pr, rm)) {\r\n    e = pr + 10;\r\n\r\n    // Truncate to the increased precision plus five rounding digits.\r\n    r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n    // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n    if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n      r = finalise(r, pr + 1, 0);\r\n    }\r\n  }\r\n\r\n  r.s = sign;\r\n  external = true;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(r, pr, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toPrecision = function (sd, rm) {\r\n  var str,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (sd === void 0) {\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n  } else {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    x = finalise(new Ctor(x), sd, rm);\r\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n  }\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n * omitted.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toSD() digits out of range: {sd}'\r\n * 'toSD() digits not an integer: {sd}'\r\n * 'toSD() rounding mode not an integer: {rm}'\r\n * 'toSD() rounding mode out of range: {rm}'\r\n *\r\n */\r\nP.toSignificantDigits = P.toSD = function (sd, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (sd === void 0) {\r\n    sd = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n  } else {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n  }\r\n\r\n  return finalise(new Ctor(x), sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal.\r\n *\r\n * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n *\r\n */\r\nP.toString = function () {\r\n  var x = this,\r\n    Ctor = x.constructor,\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n *\r\n */\r\nP.truncated = P.trunc = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 1);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal.\r\n * Unlike `toString`, negative zero will include the minus sign.\r\n *\r\n */\r\nP.valueOf = P.toJSON = function () {\r\n  var x = this,\r\n    Ctor = x.constructor,\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n  return x.isNeg() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n// Add aliases to match BigDecimal method names.\r\n// P.add = P.plus;\r\nP.subtract = P.minus;\r\nP.multiply = P.times;\r\nP.divide = P.div;\r\nP.remainder = P.mod;\r\nP.compareTo = P.cmp;\r\nP.negate = P.neg;\r\n */\r\n\r\n\r\n// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n/*\r\n *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n *                           finiteToString, naturalExponential, naturalLogarithm\r\n *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n *  convertBase              toStringBinary, parseOther\r\n *  cos                      P.cos\r\n *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n *                           taylorSeries, atan2, parseOther\r\n *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n *                           naturalLogarithm, ceil, floor, round, trunc\r\n *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n *                           toStringBinary\r\n *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n *  getLn10                  P.logarithm, naturalLogarithm\r\n *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n *  getPrecision             P.precision, P.toFraction\r\n *  getZeroString            digitsToString, finiteToString\r\n *  intPow                   P.toPower, parseOther\r\n *  isOdd                    toLessThanHalfPi\r\n *  maxOrMin                 max, min\r\n *  naturalExponential       P.naturalExponential, P.toPower\r\n *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n *                           P.toPower, naturalExponential\r\n *  nonFiniteToString        finiteToString, toStringBinary\r\n *  parseDecimal             Decimal\r\n *  parseOther               Decimal\r\n *  sin                      P.sin\r\n *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n *  toLessThanHalfPi         P.cos, P.sin\r\n *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n *  truncate                 intPow\r\n *\r\n *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n *                           naturalLogarithm, config, parseOther, random, Decimal\r\n */\r\n\r\n\r\nfunction digitsToString(d) {\r\n  var i, k, ws,\r\n    indexOfLastWord = d.length - 1,\r\n    str = '',\r\n    w = d[0];\r\n\r\n  if (indexOfLastWord > 0) {\r\n    str += w;\r\n    for (i = 1; i < indexOfLastWord; i++) {\r\n      ws = d[i] + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n      str += ws;\r\n    }\r\n\r\n    w = d[i];\r\n    ws = w + '';\r\n    k = LOG_BASE - ws.length;\r\n    if (k) str += getZeroString(k);\r\n  } else if (w === 0) {\r\n    return '0';\r\n  }\r\n\r\n  // Remove trailing zeros of last w.\r\n  for (; w % 10 === 0;) w /= 10;\r\n\r\n  return str + w;\r\n}\r\n\r\n\r\nfunction checkInt32(i, min, max) {\r\n  if (i !== ~~i || i < min || i > max) {\r\n    throw Error(invalidArgument + i);\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n * `repeating == null` if caller is `log` or `pow`,\r\n * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n */\r\nfunction checkRoundingDigits(d, i, rm, repeating) {\r\n  var di, k, r, rd;\r\n\r\n  // Get the length of the first word of the array d.\r\n  for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n  // Is the rounding digit in the first word of d?\r\n  if (--i < 0) {\r\n    i += LOG_BASE;\r\n    di = 0;\r\n  } else {\r\n    di = Math.ceil((i + 1) / LOG_BASE);\r\n    i %= LOG_BASE;\r\n  }\r\n\r\n  // i is the index (0 - 6) of the rounding digit.\r\n  // E.g. if within the word 3487563 the first rounding digit is 5,\r\n  // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n  k = mathpow(10, LOG_BASE - i);\r\n  rd = d[di] % k | 0;\r\n\r\n  if (repeating == null) {\r\n    if (i < 3) {\r\n      if (i == 0) rd = rd / 100 | 0;\r\n      else if (i == 1) rd = rd / 10 | 0;\r\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n    } else {\r\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n        (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n          (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n    }\r\n  } else {\r\n    if (i < 4) {\r\n      if (i == 0) rd = rd / 1000 | 0;\r\n      else if (i == 1) rd = rd / 100 | 0;\r\n      else if (i == 2) rd = rd / 10 | 0;\r\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n    } else {\r\n      r = ((repeating || rm < 4) && rd + 1 == k ||\r\n      (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n        (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n    }\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n\r\n// Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n// Eg. convertBase('255', 10, 16) returns [15, 15].\r\n// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\nfunction convertBase(str, baseIn, baseOut) {\r\n  var j,\r\n    arr = [0],\r\n    arrL,\r\n    i = 0,\r\n    strL = str.length;\r\n\r\n  for (; i < strL;) {\r\n    for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n    for (j = 0; j < arr.length; j++) {\r\n      if (arr[j] > baseOut - 1) {\r\n        if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n        arr[j + 1] += arr[j] / baseOut | 0;\r\n        arr[j] %= baseOut;\r\n      }\r\n    }\r\n  }\r\n\r\n  return arr.reverse();\r\n}\r\n\r\n\r\n/*\r\n * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n * |x| < pi/2\r\n *\r\n */\r\nfunction cosine(Ctor, x) {\r\n  var k, y,\r\n    len = x.d.length;\r\n\r\n  // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n  // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  if (len < 32) {\r\n    k = Math.ceil(len / 3);\r\n    y = Math.pow(4, -k).toString();\r\n  } else {\r\n    k = 16;\r\n    y = '2.3283064365386962890625e-10';\r\n  }\r\n\r\n  Ctor.precision += k;\r\n\r\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n  // Reverse argument reduction\r\n  for (var i = k; i--;) {\r\n    var cos2x = x.times(x);\r\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n  }\r\n\r\n  Ctor.precision -= k;\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Perform division in the specified base.\r\n */\r\nvar divide = (function () {\r\n\r\n  // Assumes non-zero x and k, and hence non-zero result.\r\n  function multiplyInteger(x, k, base) {\r\n    var temp,\r\n      carry = 0,\r\n      i = x.length;\r\n\r\n    for (x = x.slice(); i--;) {\r\n      temp = x[i] * k + carry;\r\n      x[i] = temp % base | 0;\r\n      carry = temp / base | 0;\r\n    }\r\n\r\n    if (carry) x.unshift(carry);\r\n\r\n    return x;\r\n  }\r\n\r\n  function compare(a, b, aL, bL) {\r\n    var i, r;\r\n\r\n    if (aL != bL) {\r\n      r = aL > bL ? 1 : -1;\r\n    } else {\r\n      for (i = r = 0; i < aL; i++) {\r\n        if (a[i] != b[i]) {\r\n          r = a[i] > b[i] ? 1 : -1;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n  function subtract(a, b, aL, base) {\r\n    var i = 0;\r\n\r\n    // Subtract b from a.\r\n    for (; aL--;) {\r\n      a[aL] -= i;\r\n      i = a[aL] < b[aL] ? 1 : 0;\r\n      a[aL] = i * base + a[aL] - b[aL];\r\n    }\r\n\r\n    // Remove leading zeros.\r\n    for (; !a[0] && a.length > 1;) a.shift();\r\n  }\r\n\r\n  return function (x, y, pr, rm, dp, base) {\r\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n      yL, yz,\r\n      Ctor = x.constructor,\r\n      sign = x.s == y.s ? 1 : -1,\r\n      xd = x.d,\r\n      yd = y.d;\r\n\r\n    // Either NaN, Infinity or 0?\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n        // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n        xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n    }\r\n\r\n    if (base) {\r\n      logBase = 1;\r\n      e = x.e - y.e;\r\n    } else {\r\n      base = BASE;\r\n      logBase = LOG_BASE;\r\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n    }\r\n\r\n    yL = yd.length;\r\n    xL = xd.length;\r\n    q = new Ctor(sign);\r\n    qd = q.d = [];\r\n\r\n    // Result exponent may be one less than e.\r\n    // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n    for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n    if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n    if (pr == null) {\r\n      sd = pr = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else if (dp) {\r\n      sd = pr + (x.e - y.e) + 1;\r\n    } else {\r\n      sd = pr;\r\n    }\r\n\r\n    if (sd < 0) {\r\n      qd.push(1);\r\n      more = true;\r\n    } else {\r\n\r\n      // Convert precision in number of base 10 digits to base 1e7 digits.\r\n      sd = sd / logBase + 2 | 0;\r\n      i = 0;\r\n\r\n      // divisor < 1e7\r\n      if (yL == 1) {\r\n        k = 0;\r\n        yd = yd[0];\r\n        sd++;\r\n\r\n        // k is the carry.\r\n        for (; (i < xL || k) && sd--; i++) {\r\n          t = k * base + (xd[i] || 0);\r\n          qd[i] = t / yd | 0;\r\n          k = t % yd | 0;\r\n        }\r\n\r\n        more = k || i < xL;\r\n\r\n      // divisor >= 1e7\r\n      } else {\r\n\r\n        // Normalise xd and yd so highest order digit of yd is >= base/2\r\n        k = base / (yd[0] + 1) | 0;\r\n\r\n        if (k > 1) {\r\n          yd = multiplyInteger(yd, k, base);\r\n          xd = multiplyInteger(xd, k, base);\r\n          yL = yd.length;\r\n          xL = xd.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xd.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL;) rem[remL++] = 0;\r\n\r\n        yz = yd.slice();\r\n        yz.unshift(0);\r\n        yd0 = yd[0];\r\n\r\n        if (yd[1] >= base / 2) ++yd0;\r\n\r\n        do {\r\n          k = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yd, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, k.\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // k will be how many times the divisor goes into the current remainder.\r\n            k = rem0 / yd0 | 0;\r\n\r\n            //  Algorithm:\r\n            //  1. product = divisor * trial digit (k)\r\n            //  2. if product > remainder: product -= divisor, k--\r\n            //  3. remainder -= product\r\n            //  4. if product was < remainder at 2:\r\n            //    5. compare new remainder and divisor\r\n            //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n            if (k > 1) {\r\n              if (k >= base) k = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiplyInteger(yd, k, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              cmp = compare(prod, rem, prodL, remL);\r\n\r\n              // product > remainder.\r\n              if (cmp == 1) {\r\n                k--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n              }\r\n            } else {\r\n\r\n              // cmp is -1.\r\n              // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n              // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n              if (k == 0) cmp = k = 1;\r\n              prod = yd.slice();\r\n            }\r\n\r\n            prodL = prod.length;\r\n            if (prodL < remL) prod.unshift(0);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n\r\n            // If product was < previous remainder.\r\n            if (cmp == -1) {\r\n              remL = rem.length;\r\n\r\n              // Compare divisor and new remainder.\r\n              cmp = compare(yd, rem, yL, remL);\r\n\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              if (cmp < 1) {\r\n                k++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yd, remL, base);\r\n              }\r\n            }\r\n\r\n            remL = rem.length;\r\n          } else if (cmp === 0) {\r\n            k++;\r\n            rem = [0];\r\n          }    // if cmp === 1, k will be 0\r\n\r\n          // Add the next digit, k, to the result array.\r\n          qd[i++] = k;\r\n\r\n          // Update the remainder.\r\n          if (cmp && rem[0]) {\r\n            rem[remL++] = xd[xi] || 0;\r\n          } else {\r\n            rem = [xd[xi]];\r\n            remL = 1;\r\n          }\r\n\r\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n        more = rem[0] !== void 0;\r\n      }\r\n\r\n      // Leading zero?\r\n      if (!qd[0]) qd.shift();\r\n    }\r\n\r\n    // logBase is 1 when divide is being used for base conversion.\r\n    if (logBase == 1) {\r\n      q.e = e;\r\n      inexact = more;\r\n    } else {\r\n\r\n      // To calculate q.e, first get the number of digits of qd[0].\r\n      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n      q.e = i + e * logBase - 1;\r\n\r\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n    }\r\n\r\n    return q;\r\n  };\r\n})();\r\n\r\n\r\n/*\r\n * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n * Check for over/under-flow.\r\n */\r\n function finalise(x, sd, rm, isTruncated) {\r\n  var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n    Ctor = x.constructor;\r\n\r\n  // Don't round if sd is null or undefined.\r\n  out: if (sd != null) {\r\n    xd = x.d;\r\n\r\n    // Infinity/NaN.\r\n    if (!xd) return x;\r\n\r\n    // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n    // w: the word of xd containing rd, a base 1e7 number.\r\n    // xdi: the index of w within xd.\r\n    // digits: the number of digits of w.\r\n    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n    // they had leading zeros)\r\n    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n    // Get the length of the first word of the digits array xd.\r\n    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n    i = sd - digits;\r\n\r\n    // Is the rounding digit in the first word of xd?\r\n    if (i < 0) {\r\n      i += LOG_BASE;\r\n      j = sd;\r\n      w = xd[xdi = 0];\r\n\r\n      // Get the rounding digit at index j of w.\r\n      rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n    } else {\r\n      xdi = Math.ceil((i + 1) / LOG_BASE);\r\n      k = xd.length;\r\n      if (xdi >= k) {\r\n        if (isTruncated) {\r\n\r\n          // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n          for (; k++ <= xdi;) xd.push(0);\r\n          w = rd = 0;\r\n          digits = 1;\r\n          i %= LOG_BASE;\r\n          j = i - LOG_BASE + 1;\r\n        } else {\r\n          break out;\r\n        }\r\n      } else {\r\n        w = k = xd[xdi];\r\n\r\n        // Get the number of digits of w.\r\n        for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n        // Get the index of rd within w.\r\n        i %= LOG_BASE;\r\n\r\n        // Get the index of rd within w, adjusted for leading zeros.\r\n        // The number of leading zeros of w is given by LOG_BASE - digits.\r\n        j = i - LOG_BASE + digits;\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      }\r\n    }\r\n\r\n    // Are there any non-zero digits after the rounding digit?\r\n    isTruncated = isTruncated || sd < 0 ||\r\n      xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n    // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n    // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n    // will give 714.\r\n\r\n    roundUp = rm < 4\r\n      ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n      : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n        // Check whether the digit to the left of the rounding digit is odd.\r\n        ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n          rm == (x.s < 0 ? 8 : 7));\r\n\r\n    if (sd < 1 || !xd[0]) {\r\n      xd.length = 0;\r\n      if (roundUp) {\r\n\r\n        // Convert sd to decimal places.\r\n        sd -= x.e + 1;\r\n\r\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n        x.e = -sd || 0;\r\n      } else {\r\n\r\n        // Zero.\r\n        xd[0] = x.e = 0;\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n    // Remove excess digits.\r\n    if (i == 0) {\r\n      xd.length = xdi;\r\n      k = 1;\r\n      xdi--;\r\n    } else {\r\n      xd.length = xdi + 1;\r\n      k = mathpow(10, LOG_BASE - i);\r\n\r\n      // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n      // j > 0 means i > number of leading zeros of w.\r\n      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n    }\r\n\r\n    if (roundUp) {\r\n      for (;;) {\r\n\r\n        // Is the digit to be rounded up in the first word of xd?\r\n        if (xdi == 0) {\r\n\r\n          // i will be the length of xd[0] before k is added.\r\n          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n          j = xd[0] += k;\r\n          for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n          // if i != k the length has increased.\r\n          if (i != k) {\r\n            x.e++;\r\n            if (xd[0] == BASE) xd[0] = 1;\r\n          }\r\n\r\n          break;\r\n        } else {\r\n          xd[xdi] += k;\r\n          if (xd[xdi] != BASE) break;\r\n          xd[xdi--] = 0;\r\n          k = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n  }\r\n\r\n  if (external) {\r\n\r\n    // Overflow?\r\n    if (x.e > Ctor.maxE) {\r\n\r\n      // Infinity.\r\n      x.d = null;\r\n      x.e = NaN;\r\n\r\n    // Underflow?\r\n    } else if (x.e < Ctor.minE) {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n      // Ctor.underflow = true;\r\n    } // else Ctor.underflow = false;\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\nfunction finiteToString(x, isExp, sd) {\r\n  if (!x.isFinite()) return nonFiniteToString(x);\r\n  var k,\r\n    e = x.e,\r\n    str = digitsToString(x.d),\r\n    len = str.length;\r\n\r\n  if (isExp) {\r\n    if (sd && (k = sd - len) > 0) {\r\n      str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n    } else if (len > 1) {\r\n      str = str.charAt(0) + '.' + str.slice(1);\r\n    }\r\n\r\n    str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n  } else if (e < 0) {\r\n    str = '0.' + getZeroString(-e - 1) + str;\r\n    if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n  } else if (e >= len) {\r\n    str += getZeroString(e + 1 - len);\r\n    if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n  } else {\r\n    if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n    if (sd && (k = sd - len) > 0) {\r\n      if (e + 1 === len) str += '.';\r\n      str += getZeroString(k);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// Calculate the base 10 exponent from the base 1e7 exponent.\r\nfunction getBase10Exponent(digits, e) {\r\n  var w = digits[0];\r\n\r\n  // Add the number of digits of the first word of the digits array.\r\n  for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n  return e;\r\n}\r\n\r\n\r\nfunction getLn10(Ctor, sd, pr) {\r\n  if (sd > LN10_PRECISION) {\r\n\r\n    // Reset global state in case the exception is caught.\r\n    external = true;\r\n    if (pr) Ctor.precision = pr;\r\n    throw Error(precisionLimitExceeded);\r\n  }\r\n  return finalise(new Ctor(LN10), sd, 1, true);\r\n}\r\n\r\n\r\nfunction getPi(Ctor, sd, rm) {\r\n  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n  return finalise(new Ctor(PI), sd, rm, true);\r\n}\r\n\r\n\r\nfunction getPrecision(digits) {\r\n  var w = digits.length - 1,\r\n    len = w * LOG_BASE + 1;\r\n\r\n  w = digits[w];\r\n\r\n  // If non-zero...\r\n  if (w) {\r\n\r\n    // Subtract the number of trailing zeros of the last word.\r\n    for (; w % 10 == 0; w /= 10) len--;\r\n\r\n    // Add the number of digits of the first word.\r\n    for (w = digits[0]; w >= 10; w /= 10) len++;\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n\r\nfunction getZeroString(k) {\r\n  var zs = '';\r\n  for (; k--;) zs += '0';\r\n  return zs;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n * integer of type number.\r\n *\r\n * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n *\r\n */\r\nfunction intPow(Ctor, x, n, pr) {\r\n  var isTruncated,\r\n    r = new Ctor(1),\r\n\r\n    // Max n of 9007199254740991 takes 53 loop iterations.\r\n    // Maximum digits array length; leaves [28, 34] guard digits.\r\n    k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n  external = false;\r\n\r\n  for (;;) {\r\n    if (n % 2) {\r\n      r = r.times(x);\r\n      if (truncate(r.d, k)) isTruncated = true;\r\n    }\r\n\r\n    n = mathfloor(n / 2);\r\n    if (n === 0) {\r\n\r\n      // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n      n = r.d.length - 1;\r\n      if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n      break;\r\n    }\r\n\r\n    x = x.times(x);\r\n    truncate(x.d, k);\r\n  }\r\n\r\n  external = true;\r\n\r\n  return r;\r\n}\r\n\r\n\r\nfunction isOdd(n) {\r\n  return n.d[n.d.length - 1] & 1;\r\n}\r\n\r\n\r\n/*\r\n * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n */\r\nfunction maxOrMin(Ctor, args, ltgt) {\r\n  var y,\r\n    x = new Ctor(args[0]),\r\n    i = 0;\r\n\r\n  for (; ++i < args.length;) {\r\n    y = new Ctor(args[i]);\r\n    if (!y.s) {\r\n      x = y;\r\n      break;\r\n    } else if (x[ltgt](y)) {\r\n      x = y;\r\n    }\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n * Taylor/Maclaurin series.\r\n *\r\n * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n *\r\n * Argument reduction:\r\n *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n *   exp(x) = exp(x / 2^k)^(2^k)\r\n *\r\n * Previously, the argument was initially reduced by\r\n * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n * found to be slower than just dividing repeatedly by 32 as above.\r\n *\r\n * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n *\r\n *  exp(Infinity)  = Infinity\r\n *  exp(-Infinity) = 0\r\n *  exp(NaN)       = NaN\r\n *  exp(0)        = 1\r\n *\r\n *  exp(x) is non-terminating for any finite, non-zero x.\r\n *\r\n *  The result will always be correctly rounded.\r\n *\r\n */\r\nfunction naturalExponential(x, sd) {\r\n  var denominator, guard, j, pow, sum, t, wpr,\r\n    rep = 0,\r\n    i = 0,\r\n    k = 0,\r\n    Ctor = x.constructor,\r\n    rm = Ctor.rounding,\r\n    pr = Ctor.precision;\r\n\r\n  // 0/NaN/Infinity?\r\n  if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n    return new Ctor(x.d\r\n      ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n      : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n  }\r\n\r\n  if (sd == null) {\r\n    external = false;\r\n    wpr = pr;\r\n  } else {\r\n    wpr = sd;\r\n  }\r\n\r\n  t = new Ctor(0.03125);\r\n\r\n  // while abs(x) >= 0.1\r\n  while (x.e > -2) {\r\n\r\n    // x = x / 2^5\r\n    x = x.times(t);\r\n    k += 5;\r\n  }\r\n\r\n  // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n  // necessary to ensure the first 4 rounding digits are correct.\r\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n  wpr += guard;\r\n  denominator = pow = sum = new Ctor(1);\r\n  Ctor.precision = wpr;\r\n\r\n  for (;;) {\r\n    pow = finalise(pow.times(x), wpr, 1);\r\n    denominator = denominator.times(++i);\r\n    t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n      j = k;\r\n      while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n      // Check to see if the first 4 rounding digits are [49]999.\r\n      // If so, repeat the summation with a higher precision, otherwise\r\n      // e.g. with precision: 18, rounding: 1\r\n      // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n      // `wpr - guard` is the index of first rounding digit.\r\n      if (sd == null) {\r\n\r\n        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n          Ctor.precision = wpr += 10;\r\n          denominator = pow = t = new Ctor(1);\r\n          i = 0;\r\n          rep++;\r\n        } else {\r\n          return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n        }\r\n      } else {\r\n        Ctor.precision = pr;\r\n        return sum;\r\n      }\r\n    }\r\n\r\n    sum = t;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n *  ln(-n)        = NaN\r\n *  ln(0)         = -Infinity\r\n *  ln(-0)        = -Infinity\r\n *  ln(1)         = 0\r\n *  ln(Infinity)  = Infinity\r\n *  ln(-Infinity) = NaN\r\n *  ln(NaN)       = NaN\r\n *\r\n *  ln(n) (n != 1) is non-terminating.\r\n *\r\n */\r\nfunction naturalLogarithm(y, sd) {\r\n  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n    n = 1,\r\n    guard = 10,\r\n    x = y,\r\n    xd = x.d,\r\n    Ctor = x.constructor,\r\n    rm = Ctor.rounding,\r\n    pr = Ctor.precision;\r\n\r\n  // Is x negative or Infinity, NaN, 0 or 1?\r\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n  }\r\n\r\n  if (sd == null) {\r\n    external = false;\r\n    wpr = pr;\r\n  } else {\r\n    wpr = sd;\r\n  }\r\n\r\n  Ctor.precision = wpr += guard;\r\n  c = digitsToString(xd);\r\n  c0 = c.charAt(0);\r\n\r\n  if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n    // Argument reduction.\r\n    // The series converges faster the closer the argument is to 1, so using\r\n    // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n    // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n    // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n    // later be divided by this number, then separate out the power of 10 using\r\n    // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n    // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n    //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n    // max n is 6 (gives 0.7 - 1.3)\r\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n      x = x.times(y);\r\n      c = digitsToString(x.d);\r\n      c0 = c.charAt(0);\r\n      n++;\r\n    }\r\n\r\n    e = x.e;\r\n\r\n    if (c0 > 1) {\r\n      x = new Ctor('0.' + c);\r\n      e++;\r\n    } else {\r\n      x = new Ctor(c0 + '.' + c.slice(1));\r\n    }\r\n  } else {\r\n\r\n    // The argument reduction method above may result in overflow if the argument y is a massive\r\n    // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n    // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n    t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n    x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n    Ctor.precision = pr;\r\n\r\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n  }\r\n\r\n  // x1 is x reduced to a value near 1.\r\n  x1 = x;\r\n\r\n  // Taylor series.\r\n  // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n  // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n  x2 = finalise(x.times(x), wpr, 1);\r\n  denominator = 3;\r\n\r\n  for (;;) {\r\n    numerator = finalise(numerator.times(x2), wpr, 1);\r\n    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n      sum = sum.times(2);\r\n\r\n      // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n      // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n      if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n      sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n      // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n      // been repeated previously) and the first 4 rounding digits 9999?\r\n      // If so, restart the summation with a higher precision, otherwise\r\n      // e.g. with precision: 12, rounding: 1\r\n      // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n      // `wpr - guard` is the index of first rounding digit.\r\n      if (sd == null) {\r\n        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n          Ctor.precision = wpr += guard;\r\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n          x2 = finalise(x.times(x), wpr, 1);\r\n          denominator = rep = 1;\r\n        } else {\r\n          return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n        }\r\n      } else {\r\n        Ctor.precision = pr;\r\n        return sum;\r\n      }\r\n    }\r\n\r\n    sum = t;\r\n    denominator += 2;\r\n  }\r\n}\r\n\r\n\r\n// Infinity, NaN.\r\nfunction nonFiniteToString(x) {\r\n  // Unsigned.\r\n  return String(x.s * x.s / 0);\r\n}\r\n\r\n\r\n/*\r\n * Parse the value of a new Decimal `x` from string `str`.\r\n */\r\nfunction parseDecimal(x, str) {\r\n  var e, i, len;\r\n\r\n  // Decimal point?\r\n  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n  // Exponential form?\r\n  if ((i = str.search(/e/i)) > 0) {\r\n\r\n    // Determine exponent.\r\n    if (e < 0) e = i;\r\n    e += +str.slice(i + 1);\r\n    str = str.substring(0, i);\r\n  } else if (e < 0) {\r\n\r\n    // Integer.\r\n    e = str.length;\r\n  }\r\n\r\n  // Determine leading zeros.\r\n  for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n  // Determine trailing zeros.\r\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n  str = str.slice(i, len);\r\n\r\n  if (str) {\r\n    len -= i;\r\n    x.e = e = e - i - 1;\r\n    x.d = [];\r\n\r\n    // Transform base\r\n\r\n    // e is the base 10 exponent.\r\n    // i is where to slice str to get the first word of the digits array.\r\n    i = (e + 1) % LOG_BASE;\r\n    if (e < 0) i += LOG_BASE;\r\n\r\n    if (i < len) {\r\n      if (i) x.d.push(+str.slice(0, i));\r\n      for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n      str = str.slice(i);\r\n      i = LOG_BASE - str.length;\r\n    } else {\r\n      i -= len;\r\n    }\r\n\r\n    for (; i--;) str += '0';\r\n    x.d.push(+str);\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > x.constructor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < x.constructor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // x.constructor.underflow = true;\r\n      } // else x.constructor.underflow = false;\r\n    }\r\n  } else {\r\n\r\n    // Zero.\r\n    x.e = 0;\r\n    x.d = [0];\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n */\r\nfunction parseOther(x, str) {\r\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n  if (str === 'Infinity' || str === 'NaN') {\r\n    if (!+str) x.s = NaN;\r\n    x.e = NaN;\r\n    x.d = null;\r\n    return x;\r\n  }\r\n\r\n  if (isHex.test(str))  {\r\n    base = 16;\r\n    str = str.toLowerCase();\r\n  } else if (isBinary.test(str))  {\r\n    base = 2;\r\n  } else if (isOctal.test(str))  {\r\n    base = 8;\r\n  } else {\r\n    throw Error(invalidArgument + str);\r\n  }\r\n\r\n  // Is there a binary exponent part?\r\n  i = str.search(/p/i);\r\n\r\n  if (i > 0) {\r\n    p = +str.slice(i + 1);\r\n    str = str.substring(2, i);\r\n  } else {\r\n    str = str.slice(2);\r\n  }\r\n\r\n  // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n  // fraction part will be restored.\r\n  i = str.indexOf('.');\r\n  isFloat = i >= 0;\r\n  Ctor = x.constructor;\r\n\r\n  if (isFloat) {\r\n    str = str.replace('.', '');\r\n    len = str.length;\r\n    i = len - i;\r\n\r\n    // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n  }\r\n\r\n  xd = convertBase(str, base, BASE);\r\n  xe = xd.length - 1;\r\n\r\n  // Remove trailing zeros.\r\n  for (i = xe; xd[i] === 0; --i) xd.pop();\r\n  if (i < 0) return new Ctor(x.s * 0);\r\n  x.e = getBase10Exponent(xd, xe);\r\n  x.d = xd;\r\n  external = false;\r\n\r\n  // At what precision to perform the division to ensure exact conversion?\r\n  // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n  // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n  // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n  // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n  // Therefore using 4 * the number of digits of str will always be enough.\r\n  if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n  // Multiply by the binary exponent part if present.\r\n  if (p) x = x.times(Math.abs(p) < 54 ? Math.pow(2, p) : Decimal.pow(2, p));\r\n  external = true;\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n * |x| < pi/2\r\n *\r\n */\r\nfunction sine(Ctor, x) {\r\n  var k,\r\n    len = x.d.length;\r\n\r\n  if (len < 3) return taylorSeries(Ctor, 2, x, x);\r\n\r\n  // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n  // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n  // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  k = 1.4 * Math.sqrt(len);\r\n  k = k > 16 ? 16 : k | 0;\r\n\r\n  // Max k before Math.pow precision loss is 22\r\n  x = x.times(Math.pow(5, -k));\r\n  x = taylorSeries(Ctor, 2, x, x);\r\n\r\n  // Reverse argument reduction\r\n  var sin2_x,\r\n    d5 = new Ctor(5),\r\n    d16 = new Ctor(16),\r\n    d20 = new Ctor(20);\r\n  for (; k--;) {\r\n    sin2_x = x.times(x);\r\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n  var j, t, u, x2,\r\n    i = 1,\r\n    pr = Ctor.precision,\r\n    k = Math.ceil(pr / LOG_BASE);\r\n\r\n  external = false;\r\n  x2 = x.times(x);\r\n  u = new Ctor(y);\r\n\r\n  for (;;) {\r\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n    t = u.plus(y);\r\n\r\n    if (t.d[k] !== void 0) {\r\n      for (j = k; t.d[j] === u.d[j] && j--;);\r\n      if (j == -1) break;\r\n    }\r\n\r\n    j = u;\r\n    u = y;\r\n    y = t;\r\n    t = j;\r\n    i++;\r\n  }\r\n\r\n  external = true;\r\n  t.d.length = k + 1;\r\n\r\n  return t;\r\n}\r\n\r\n\r\n// Return the absolute value of `x` reduced to less than or equal to half pi.\r\nfunction toLessThanHalfPi(Ctor, x) {\r\n  var t,\r\n    isNeg = x.s < 0,\r\n    pi = getPi(Ctor, Ctor.precision, 1),\r\n    halfPi = pi.times(0.5);\r\n\r\n  x = x.abs();\r\n\r\n  if (x.lte(halfPi)) {\r\n    quadrant = isNeg ? 4 : 1;\r\n    return x;\r\n  }\r\n\r\n  t = x.divToInt(pi);\r\n\r\n  if (t.isZero()) {\r\n    quadrant = isNeg ? 3 : 2;\r\n  } else {\r\n    x = x.minus(t.times(pi));\r\n\r\n    // 0 <= x < pi\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n      return x;\r\n    }\r\n\r\n    quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n  }\r\n\r\n  return x.minus(pi).abs();\r\n}\r\n\r\n\r\n/*\r\n * Return the value of Decimal `x` as a string in base `baseOut`.\r\n *\r\n * If the optional `sd` argument is present include a binary exponent suffix.\r\n */\r\nfunction toStringBinary(x, baseOut, sd, rm) {\r\n  var base, e, i, k, len, roundUp, str, xd, y,\r\n    Ctor = x.constructor,\r\n    isExp = sd !== void 0;\r\n\r\n  if (isExp) {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n  } else {\r\n    sd = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n  }\r\n\r\n  if (!x.isFinite()) {\r\n    str = nonFiniteToString(x);\r\n  } else {\r\n    str = finiteToString(x);\r\n    i = str.indexOf('.');\r\n\r\n    // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n    // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n    // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n    // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n    if (isExp) {\r\n      base = 2;\r\n      if (baseOut == 16) {\r\n        sd = sd * 4 - 3;\r\n      } else if (baseOut == 8) {\r\n        sd = sd * 3 - 2;\r\n      }\r\n    } else {\r\n      base = baseOut;\r\n    }\r\n\r\n    // Convert the number as an integer then divide the result by its base raised to a power such\r\n    // that the fraction part will be restored.\r\n\r\n    // Non-integer.\r\n    if (i >= 0) {\r\n      str = str.replace('.', '');\r\n      y = new Ctor(1);\r\n      y.e = str.length - i;\r\n      y.d = convertBase(finiteToString(y), 10, base);\r\n      y.e = y.d.length;\r\n    }\r\n\r\n    xd = convertBase(str, 10, base);\r\n    e = len = xd.length;\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] == 0;) xd.pop();\r\n\r\n    if (!xd[0]) {\r\n      str = isExp ? '0p+0' : '0';\r\n    } else {\r\n      if (i < 0) {\r\n        e--;\r\n      } else {\r\n        x = new Ctor(x);\r\n        x.d = xd;\r\n        x.e = e;\r\n        x = divide(x, y, sd, rm, 0, base);\r\n        xd = x.d;\r\n        e = x.e;\r\n        roundUp = inexact;\r\n      }\r\n\r\n      // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      i = xd[sd];\r\n      k = base / 2;\r\n      roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n      roundUp = rm < 4\r\n        ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n        : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n          rm === (x.s < 0 ? 8 : 7));\r\n\r\n      xd.length = sd;\r\n\r\n      if (roundUp) {\r\n\r\n        // Rounding up may mean the previous digit has to be rounded up and so on.\r\n        for (; ++xd[--sd] > base - 1;) {\r\n          xd[sd] = 0;\r\n          if (!sd) {\r\n            ++e;\r\n            xd.unshift(1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Determine trailing zeros.\r\n      for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n      // E.g. [4, 11, 15] becomes 4bf.\r\n      for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n      // Add binary exponent suffix?\r\n      if (isExp) {\r\n        if (len > 1) {\r\n          if (baseOut == 16 || baseOut == 8) {\r\n            i = baseOut == 16 ? 4 : 3;\r\n            for (--len; len % i; len++) str += '0';\r\n            xd = convertBase(str, base, baseOut);\r\n            for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n            // xd[0] will always be be 1\r\n            for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n          } else {\r\n            str = str.charAt(0) + '.' + str.slice(1);\r\n          }\r\n        }\r\n\r\n        str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n      } else if (e < 0) {\r\n        for (; ++e;) str = '0' + str;\r\n        str = '0.' + str;\r\n      } else {\r\n        if (++e > len) for (e -= len; e-- ;) str += '0';\r\n        else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n  }\r\n\r\n  return x.s < 0 ? '-' + str : str;\r\n}\r\n\r\n\r\n// Does not strip trailing zeros.\r\nfunction truncate(arr, len) {\r\n  if (arr.length > len) {\r\n    arr.length = len;\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n// Decimal methods\r\n\r\n\r\n/*\r\n *  abs\r\n *  acos\r\n *  acosh\r\n *  add\r\n *  asin\r\n *  asinh\r\n *  atan\r\n *  atanh\r\n *  atan2\r\n *  cbrt\r\n *  ceil\r\n *  clone\r\n *  config\r\n *  cos\r\n *  cosh\r\n *  div\r\n *  exp\r\n *  floor\r\n *  hypot\r\n *  ln\r\n *  log\r\n *  log2\r\n *  log10\r\n *  max\r\n *  min\r\n *  mod\r\n *  mul\r\n *  pow\r\n *  random\r\n *  round\r\n *  set\r\n *  sign\r\n *  sin\r\n *  sinh\r\n *  sqrt\r\n *  sub\r\n *  tan\r\n *  tanh\r\n *  trunc\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the absolute value of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction abs(x) {\r\n  return new this(x).abs();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction acos(x) {\r\n  return new this(x).acos();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction acosh(x) {\r\n  return new this(x).acosh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction add(x, y) {\r\n  return new this(x).plus(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction asin(x) {\r\n  return new this(x).asin();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction asinh(x) {\r\n  return new this(x).asinh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction atan(x) {\r\n  return new this(x).atan();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction atanh(x) {\r\n  return new this(x).atanh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi, pi]\r\n *\r\n * y {number|string|Decimal} The y-coordinate.\r\n * x {number|string|Decimal} The x-coordinate.\r\n *\r\n * atan2(0, -0)               = pi\r\n * atan2(0, +0)               = 0\r\n * atan2(0, -x)               = pi for x > 0\r\n * atan2(0, x)                = 0 for x > 0\r\n * atan2(-y, 0)               = -pi/2 for y > 0\r\n * atan2(y, 0)                = pi/2 for y > 0\r\n * atan2(y, -Infinity)        = pi for finite y > 0\r\n * atan2(y, +Infinity)        = 0 for finite y > 0\r\n * atan2(Infinity, x)         = pi/2 for finite x\r\n * atan2(Infinity, -Infinity) = 3*pi/4\r\n * atan2(Infinity, +Infinity) = pi/4\r\n * atan2(NaN, x) = NaN\r\n * atan2(y, NaN) = NaN\r\n *\r\n */\r\nfunction atan2(y, x) {\r\n  y = new this(y);\r\n  x = new this(x);\r\n  var r,\r\n    pr = this.precision,\r\n    rm = this.rounding,\r\n    wpr = pr + 4;\r\n\r\n  // Either NaN\r\n  if (!y.s || !x.s) {\r\n    r = new this(NaN);\r\n\r\n  // Both Infinity\r\n  } else if (!y.d && !x.d) {\r\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n    r.s = y.s;\r\n\r\n  // x is Infinity or y is 0\r\n  } else if (!x.d || y.isZero()) {\r\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n    r.s = y.s;\r\n\r\n  // y is Infinity or x is 0\r\n  } else if (!y.d || x.isZero()) {\r\n    r = getPi(this, wpr, 1).times(0.5);\r\n    r.s = y.s;\r\n\r\n  // Both non-zero and finite\r\n  } else if (x.s < 0) {\r\n    this.precision = wpr;\r\n    this.rounding = 1;\r\n    r = this.atan(divide(y, x, wpr, 1));\r\n    x = getPi(this, wpr, 1);\r\n    this.precision = pr;\r\n    this.rounding = rm;\r\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n  } else {\r\n    r = this.atan(divide(y, x, wpr, 1));\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction cbrt(x) {\r\n  return new this(x).cbrt();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction ceil(x) {\r\n  return finalise(x = new this(x), x.e + 1, 2);\r\n}\r\n\r\n\r\n/*\r\n * Configure global settings for a Decimal constructor.\r\n *\r\n * `obj` is an object with one or more of the following properties,\r\n *\r\n *   precision  {number}\r\n *   rounding   {number}\r\n *   toExpNeg   {number}\r\n *   toExpPos   {number}\r\n *   maxE       {number}\r\n *   minE       {number}\r\n *   modulo     {number}\r\n *   crypto     {boolean|number}\r\n *\r\n * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n *\r\n */\r\nfunction config(obj) {\r\n  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n  var i, p, v,\r\n    ps = [\r\n      'precision', 1, MAX_DIGITS,\r\n      'rounding', 0, 8,\r\n      'toExpNeg', -EXP_LIMIT, 0,\r\n      'toExpPos', 0, EXP_LIMIT,\r\n      'maxE', 0, EXP_LIMIT,\r\n      'minE', -EXP_LIMIT, 0,\r\n      'modulo', 0, 9\r\n    ];\r\n\r\n  for (i = 0; i < ps.length; i += 3) {\r\n    if ((v = obj[p = ps[i]]) !== void 0) {\r\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n      else throw Error(invalidArgument + p + ': ' + v);\r\n    }\r\n  }\r\n\r\n  if ((v = obj[p = 'crypto']) !== void 0) {\r\n    if (v === true || v === false || v === 0 || v === 1) {\r\n      if (v) {\r\n        if (typeof crypto != 'undefined' && crypto &&\r\n          (crypto.getRandomValues || crypto.randomBytes)) {\r\n          this[p] = true;\r\n        } else {\r\n          throw Error(cryptoUnavailable);\r\n        }\r\n      } else {\r\n        this[p] = false;\r\n      }\r\n    } else {\r\n      throw Error(invalidArgument + p + ': ' + v);\r\n    }\r\n  }\r\n\r\n  return this;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction cos(x) {\r\n  return new this(x).cos();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction cosh(x) {\r\n  return new this(x).cosh();\r\n}\r\n\r\n\r\n/*\r\n * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n * constructor.\r\n *\r\n */\r\nfunction clone(obj) {\r\n  var i, p, ps;\r\n\r\n  /*\r\n   * The Decimal constructor and exported function.\r\n   * Return a new Decimal instance.\r\n   *\r\n   * v {number|string|Decimal} A numeric value.\r\n   *\r\n   */\r\n  function Decimal(v) {\r\n    var e, i, t,\r\n      x = this;\r\n\r\n    // Decimal called without new.\r\n    if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n    // which points to Object.\r\n    x.constructor = Decimal;\r\n\r\n    // Duplicate.\r\n    if (v instanceof Decimal) {\r\n      x.s = v.s;\r\n      x.e = v.e;\r\n      x.d = (v = v.d) ? v.slice() : v;\r\n      return;\r\n    }\r\n\r\n    t = typeof v;\r\n\r\n    if (t === 'number') {\r\n      if (v === 0) {\r\n        x.s = 1 / v < 0 ? -1 : 1;\r\n        x.e = 0;\r\n        x.d = [0];\r\n        return;\r\n      }\r\n\r\n      if (v < 0) {\r\n        v = -v;\r\n        x.s = -1;\r\n      } else {\r\n        x.s = 1;\r\n      }\r\n\r\n      // Fast path for small integers.\r\n      if (v === ~~v && v < 1e7) {\r\n        for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n        x.e = e;\r\n        x.d = [v];\r\n        return;\r\n\r\n      // Infinity, NaN.\r\n      } else if (v * 0 !== 0) {\r\n        if (!v) x.s = NaN;\r\n        x.e = NaN;\r\n        x.d = null;\r\n        return;\r\n      }\r\n\r\n      return parseDecimal(x, v.toString());\r\n\r\n    } else if (t !== 'string') {\r\n      throw Error(invalidArgument + v);\r\n    }\r\n\r\n    // Minus sign?\r\n    if (v.charCodeAt(0) === 45) {\r\n      v = v.slice(1);\r\n      x.s = -1;\r\n    } else {\r\n      x.s = 1;\r\n    }\r\n\r\n    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n  }\r\n\r\n  Decimal.prototype = P;\r\n\r\n  Decimal.ROUND_UP = 0;\r\n  Decimal.ROUND_DOWN = 1;\r\n  Decimal.ROUND_CEIL = 2;\r\n  Decimal.ROUND_FLOOR = 3;\r\n  Decimal.ROUND_HALF_UP = 4;\r\n  Decimal.ROUND_HALF_DOWN = 5;\r\n  Decimal.ROUND_HALF_EVEN = 6;\r\n  Decimal.ROUND_HALF_CEIL = 7;\r\n  Decimal.ROUND_HALF_FLOOR = 8;\r\n  Decimal.EUCLID = 9;\r\n\r\n  Decimal.config = Decimal.set = config;\r\n  Decimal.clone = clone;\r\n\r\n  Decimal.abs = abs;\r\n  Decimal.acos = acos;\r\n  Decimal.acosh = acosh;        // ES6\r\n  Decimal.add = add;\r\n  Decimal.asin = asin;\r\n  Decimal.asinh = asinh;        // ES6\r\n  Decimal.atan = atan;\r\n  Decimal.atanh = atanh;        // ES6\r\n  Decimal.atan2 = atan2;\r\n  Decimal.cbrt = cbrt;          // ES6\r\n  Decimal.ceil = ceil;\r\n  Decimal.cos = cos;\r\n  Decimal.cosh = cosh;          // ES6\r\n  Decimal.div = div;\r\n  Decimal.exp = exp;\r\n  Decimal.floor = floor;\r\n  Decimal.hypot = hypot;        // ES6\r\n  Decimal.ln = ln;\r\n  Decimal.log = log;\r\n  Decimal.log10 = log10;        // ES6\r\n  Decimal.log2 = log2;          // ES6\r\n  Decimal.max = max;\r\n  Decimal.min = min;\r\n  Decimal.mod = mod;\r\n  Decimal.mul = mul;\r\n  Decimal.pow = pow;\r\n  Decimal.random = random;\r\n  Decimal.round = round;\r\n  Decimal.sign = sign;          // ES6\r\n  Decimal.sin = sin;\r\n  Decimal.sinh = sinh;          // ES6\r\n  Decimal.sqrt = sqrt;\r\n  Decimal.sub = sub;\r\n  Decimal.tan = tan;\r\n  Decimal.tanh = tanh;          // ES6\r\n  Decimal.trunc = trunc;        // ES6\r\n\r\n  if (obj === void 0) obj = {};\r\n  if (obj) {\r\n    ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n    for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n  }\r\n\r\n  Decimal.config(obj);\r\n\r\n  return Decimal;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction div(x, y) {\r\n  return new this(x).div(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n *\r\n */\r\nfunction exp(x) {\r\n  return new this(x).exp();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction floor(x) {\r\n  return finalise(x = new this(x), x.e + 1, 3);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n *\r\n */\r\nfunction hypot() {\r\n  var i, n,\r\n    t = new this(0);\r\n\r\n  external = false;\r\n\r\n  for (i = 0; i < arguments.length;) {\r\n    n = new this(arguments[i++]);\r\n    if (!n.d) {\r\n      if (n.s) {\r\n        external = true;\r\n        return new this(1 / 0);\r\n      }\r\n      t = n;\r\n    } else if (t.d) {\r\n      t = t.plus(n.times(n));\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return t.sqrt();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction ln(x) {\r\n  return new this(x).ln();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * log[y](x)\r\n *\r\n * x {number|string|Decimal} The argument of the logarithm.\r\n * y {number|string|Decimal} The base of the logarithm.\r\n *\r\n */\r\nfunction log(x, y) {\r\n  return new this(x).log(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction log2(x) {\r\n  return new this(x).log(2);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction log10(x) {\r\n  return new this(x).log(10);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */\r\nfunction max() {\r\n  return maxOrMin(this, arguments, 'lt');\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */\r\nfunction min() {\r\n  return maxOrMin(this, arguments, 'gt');\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction mod(x, y) {\r\n  return new this(x).mod(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction mul(x, y) {\r\n  return new this(x).mul(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The base.\r\n * y {number|string|Decimal} The exponent.\r\n *\r\n */\r\nfunction pow(x, y) {\r\n  return new this(x).pow(y);\r\n}\r\n\r\n\r\n/*\r\n * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n * are produced).\r\n *\r\n * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n *\r\n */\r\nfunction random(sd) {\r\n  var d, e, k, n,\r\n    i = 0,\r\n    r = new this(1),\r\n    rd = [];\r\n\r\n  if (sd === void 0) sd = this.precision;\r\n  else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n  k = Math.ceil(sd / LOG_BASE);\r\n\r\n  if (!this.crypto) {\r\n    for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n  // Browsers supporting crypto.getRandomValues.\r\n  } else if (crypto.getRandomValues) {\r\n    d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n    for (; i < k;) {\r\n      n = d[i];\r\n\r\n      // 0 <= n < 4294967296\r\n      // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n      if (n >= 4.29e9) {\r\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n      } else {\r\n\r\n        // 0 <= n <= 4289999999\r\n        // 0 <= (n % 1e7) <= 9999999\r\n        rd[i++] = n % 1e7;\r\n      }\r\n    }\r\n\r\n  // Node.js supporting crypto.randomBytes.\r\n  } else if (crypto.randomBytes) {\r\n\r\n    // buffer\r\n    d = crypto.randomBytes(k *= 4);\r\n\r\n    for (; i < k;) {\r\n\r\n      // 0 <= n < 2147483648\r\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n      // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n      if (n >= 2.14e9) {\r\n        crypto.randomBytes(4).copy(d, i);\r\n      } else {\r\n\r\n        // 0 <= n <= 2139999999\r\n        // 0 <= (n % 1e7) <= 9999999\r\n        rd.push(n % 1e7);\r\n        i += 4;\r\n      }\r\n    }\r\n\r\n    i = k / 4;\r\n  } else {\r\n    throw Error(cryptoUnavailable);\r\n  }\r\n\r\n  k = rd[--i];\r\n  sd %= LOG_BASE;\r\n\r\n  // Convert trailing digits to zeros according to sd.\r\n  if (k && sd) {\r\n    n = mathpow(10, LOG_BASE - sd);\r\n    rd[i] = (k / n | 0) * n;\r\n  }\r\n\r\n  // Remove trailing words which are zero.\r\n  for (; rd[i] === 0; i--) rd.pop();\r\n\r\n  // Zero?\r\n  if (i < 0) {\r\n    e = 0;\r\n    rd = [0];\r\n  } else {\r\n    e = -1;\r\n\r\n    // Remove leading words which are zero and adjust exponent accordingly.\r\n    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n    // Count the digits of the first word of rd to determine leading zeros.\r\n    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n    // Adjust the exponent for leading zeros of the first word of rd.\r\n    if (k < LOG_BASE) e -= LOG_BASE - k;\r\n  }\r\n\r\n  r.e = e;\r\n  r.d = rd;\r\n\r\n  return r;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n *\r\n * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction round(x) {\r\n  return finalise(x = new this(x), x.e + 1, this.rounding);\r\n}\r\n\r\n\r\n/*\r\n * Return\r\n *   1    if x > 0,\r\n *  -1    if x < 0,\r\n *   0    if x is 0,\r\n *  -0    if x is -0,\r\n *   NaN  otherwise\r\n *\r\n */\r\nfunction sign(x) {\r\n  x = new this(x);\r\n  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction sin(x) {\r\n  return new this(x).sin();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction sinh(x) {\r\n  return new this(x).sinh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction sqrt(x) {\r\n  return new this(x).sqrt();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction sub(x, y) {\r\n  return new this(x).sub(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction tan(x) {\r\n  return new this(x).tan();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction tanh(x) {\r\n  return new this(x).tanh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` truncated to an integer.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction trunc(x) {\r\n  return finalise(x = new this(x), x.e + 1, 1);\r\n}\r\n\r\n\r\n// Create and configure initial Decimal constructor.\r\nDecimal = clone(defaults);\r\n\r\n// Create the internal constants from their string values.\r\nLN10 = new Decimal(ln10);\r\nPI = new Decimal(pi);\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = Decimal;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n\t\"short\": [\n\t\t\"\",\n\t\t\"K\",\n\t\t\"M\",\n\t\t\"Md\",\n\t\t\"B\",\n\t\t\"Bd\",\n\t\t\"T\",\n\t\t\"Td\",\n\t\t\"Qa\",\n\t\t\"Qad\",\n\t\t\"Qi\",\n\t\t\"Qid\",\n\t\t\"Sx\",\n\t\t\"Sxd\",\n\t\t\"Sp\",\n\t\t\"Spd\",\n\t\t\"Oc\",\n\t\t\"Od\",\n\t\t\"No\",\n\t\t\"Nd\",\n\t\t\"Dc\",\n\t\t\"Dd\",\n\t\t\"UDc\",\n\t\t\"UDd\",\n\t\t\"DDc\",\n\t\t\"DDd\",\n\t\t\"TDc\",\n\t\t\"TDd\",\n\t\t\"QaDc\",\n\t\t\"QaDd\",\n\t\t\"QiDc\",\n\t\t\"QiDd\",\n\t\t\"SxDc\",\n\t\t\"SxDd\",\n\t\t\"SpDc\",\n\t\t\"SpDd\",\n\t\t\"ODc\",\n\t\t\"ODd\",\n\t\t\"NDc\",\n\t\t\"NDd\",\n\t\t\"Vi\",\n\t\t\"Vd\",\n\t\t\"UVi\",\n\t\t\"UVd\",\n\t\t\"DVi\",\n\t\t\"DVd\",\n\t\t\"TVi\",\n\t\t\"TVd\",\n\t\t\"QaVi\",\n\t\t\"QaVd\",\n\t\t\"QiVi\",\n\t\t\"QiVd\",\n\t\t\"SxVi\",\n\t\t\"SxVd\",\n\t\t\"SpVi\",\n\t\t\"SpVd\",\n\t\t\"OVi\",\n\t\t\"OVd\",\n\t\t\"NVi\",\n\t\t\"NVd\",\n\t\t\"Tg\",\n\t\t\"TD\",\n\t\t\"UTg\",\n\t\t\"UTD\",\n\t\t\"DTg\",\n\t\t\"DTD\",\n\t\t\"TTg\",\n\t\t\"TTD\",\n\t\t\"QaTg\",\n\t\t\"QaTD\",\n\t\t\"QiTg\",\n\t\t\"QiTD\",\n\t\t\"SxTg\",\n\t\t\"SxTD\",\n\t\t\"SpTg\",\n\t\t\"SpTD\",\n\t\t\"OTg\",\n\t\t\"OTD\",\n\t\t\"NTg\",\n\t\t\"NTD\",\n\t\t\"Qd\",\n\t\t\"QD\",\n\t\t\"UQd\",\n\t\t\"UQD\",\n\t\t\"DQd\",\n\t\t\"DQD\",\n\t\t\"TQd\",\n\t\t\"TQD\",\n\t\t\"QaQd\",\n\t\t\"QaQD\"\n\t],\n\t\"full\": [\n\t\t\"\",\n\t\t\" thousand\",\n\t\t\" million\",\n\t\t\" milliard\",\n\t\t\" billion\",\n\t\t\" billiard\",\n\t\t\" trillion\",\n\t\t\" trilliard\",\n\t\t\" quadrillion\",\n\t\t\" quadrilliard\",\n\t\t\" quintillion\",\n\t\t\" quintilliard\",\n\t\t\" sextillion\",\n\t\t\" sextilliard\",\n\t\t\" septillion\",\n\t\t\" septilliard\",\n\t\t\" octillion\",\n\t\t\" octilliard\",\n\t\t\" nonillion\",\n\t\t\" nonilliard\",\n\t\t\" decillion\",\n\t\t\" decilliard\",\n\t\t\" undecillion\",\n\t\t\" undecilliard\",\n\t\t\" duodecillion\",\n\t\t\" duodecilliard\",\n\t\t\" tredecillion\",\n\t\t\" tredecilliard\",\n\t\t\" quattuordecillion\",\n\t\t\" quattuordecilliard\",\n\t\t\" quinquadecillion\",\n\t\t\" quinquadecilliard\",\n\t\t\" sedecillion\",\n\t\t\" sedecilliard\",\n\t\t\" septendecillion\",\n\t\t\" septendecilliard\",\n\t\t\" octodecillion\",\n\t\t\" octodecilliard\",\n\t\t\" novendecillion\",\n\t\t\" novendecilliard\",\n\t\t\" vigintillion\",\n\t\t\" vigintilliard\",\n\t\t\" unvigintillion\",\n\t\t\" unvigintilliard\",\n\t\t\" duovigintillion\",\n\t\t\" duovigintilliard\",\n\t\t\" tresvigintillion\",\n\t\t\" tresvigintilliard\",\n\t\t\" quattuorvigintillion\",\n\t\t\" quattuorvigintilliard\",\n\t\t\" quinquavigintillion\",\n\t\t\" quinquavigintilliard\",\n\t\t\" sesvigintillion\",\n\t\t\" sesvigintilliard\",\n\t\t\" septemvigintillion\",\n\t\t\" septemvigintilliard\",\n\t\t\" octovigintillion\",\n\t\t\" octovigintilliard\",\n\t\t\" novemvigintillion\",\n\t\t\" novemvigintilliard\",\n\t\t\" trigintillion\",\n\t\t\" trigintilliard\",\n\t\t\" untrigintillion\",\n\t\t\" untrigintilliard\",\n\t\t\" duotrigintillion\",\n\t\t\" duotrigintilliard\",\n\t\t\" trestrigintillion\",\n\t\t\" trestrigintilliard\",\n\t\t\" quattuortrigintillion\",\n\t\t\" quattuortrigintilliard\",\n\t\t\" quinquatrigintillion\",\n\t\t\" quinquatrigintilliard\",\n\t\t\" sestrigintillion\",\n\t\t\" sestrigintilliard\",\n\t\t\" septentrigintillion\",\n\t\t\" septentrigintilliard\",\n\t\t\" octotrigintillion\",\n\t\t\" octotrigintilliard\",\n\t\t\" noventrigintillion\",\n\t\t\" noventrigintilliard\",\n\t\t\" quadragintillion\",\n\t\t\" quadragintilliard\",\n\t\t\" unquadragintillion\",\n\t\t\" unquadragintilliard\"\n\t]\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n\t\"short\": [\n\t\t\"\",\n\t\t\"K\",\n\t\t\"M\",\n\t\t\"B\",\n\t\t\"T\",\n\t\t\"Qa\",\n\t\t\"Qi\",\n\t\t\"Sx\",\n\t\t\"Sp\",\n\t\t\"Oc\",\n\t\t\"No\",\n\t\t\"Dc\",\n\t\t\"UDc\",\n\t\t\"DDc\",\n\t\t\"TDc\",\n\t\t\"QaDc\",\n\t\t\"QiDc\",\n\t\t\"SxDc\",\n\t\t\"SpDc\",\n\t\t\"ODc\",\n\t\t\"NDc\",\n\t\t\"Vi\",\n\t\t\"UVi\",\n\t\t\"DVi\",\n\t\t\"TVi\",\n\t\t\"QaVi\",\n\t\t\"QiVi\",\n\t\t\"SxVi\",\n\t\t\"SpVi\",\n\t\t\"OVi\",\n\t\t\"NVi\",\n\t\t\"Tg\",\n\t\t\"UTg\",\n\t\t\"DTg\",\n\t\t\"TTg\",\n\t\t\"QaTg\",\n\t\t\"QiTg\",\n\t\t\"SxTg\",\n\t\t\"SpTg\",\n\t\t\"OTg\",\n\t\t\"NTg\",\n\t\t\"Qd\",\n\t\t\"UQd\",\n\t\t\"DQd\",\n\t\t\"TQd\",\n\t\t\"QaQd\",\n\t\t\"QiQd\",\n\t\t\"SxQd\",\n\t\t\"SpQd\",\n\t\t\"OQd\",\n\t\t\"NQd\",\n\t\t\"Qq\",\n\t\t\"UQq\",\n\t\t\"DQq\",\n\t\t\"TQq\",\n\t\t\"QaQq\",\n\t\t\"QiQq\",\n\t\t\"SxQq\",\n\t\t\"SpQq\",\n\t\t\"OQq\",\n\t\t\"NQq\",\n\t\t\"Sg\",\n\t\t\"USg\",\n\t\t\"DSg\",\n\t\t\"TSg\",\n\t\t\"QaSg\",\n\t\t\"QiSg\",\n\t\t\"SxSg\",\n\t\t\"SpSg\",\n\t\t\"OSg\",\n\t\t\"NSg\",\n\t\t\"St\",\n\t\t\"USt\",\n\t\t\"DSt\",\n\t\t\"TSt\",\n\t\t\"QaSt\",\n\t\t\"QiSt\",\n\t\t\"SxSt\",\n\t\t\"SpSt\",\n\t\t\"OSt\",\n\t\t\"NSt\",\n\t\t\"Og\",\n\t\t\"UOg\",\n\t\t\"DOg\",\n\t\t\"TOg\",\n\t\t\"QaOg\",\n\t\t\"QiOg\",\n\t\t\"SxOg\",\n\t\t\"SpOg\",\n\t\t\"OOg\",\n\t\t\"NOg\"\n\t],\n\t\"full\": [\n\t\t\"\",\n\t\t\" thousand\",\n\t\t\" million\",\n\t\t\" billion\",\n\t\t\" trillion\",\n\t\t\" quadrillion\",\n\t\t\" quintillion\",\n\t\t\" sextillion\",\n\t\t\" septillion\",\n\t\t\" octillion\",\n\t\t\" nonillion\",\n\t\t\" decillion\",\n\t\t\" undecillion\",\n\t\t\" duodecillion\",\n\t\t\" tredecillion\",\n\t\t\" quattuordecillion\",\n\t\t\" quinquadecillion\",\n\t\t\" sedecillion\",\n\t\t\" septendecillion\",\n\t\t\" octodecillion\",\n\t\t\" novendecillion\",\n\t\t\" vigintillion\",\n\t\t\" unvigintillion\",\n\t\t\" duovigintillion\",\n\t\t\" tresvigintillion\",\n\t\t\" quattuorvigintillion\",\n\t\t\" quinquavigintillion\",\n\t\t\" sesvigintillion\",\n\t\t\" septemvigintillion\",\n\t\t\" octovigintillion\",\n\t\t\" novemvigintillion\",\n\t\t\" trigintillion\",\n\t\t\" untrigintillion\",\n\t\t\" duotrigintillion\",\n\t\t\" trestrigintillion\",\n\t\t\" quattuortrigintillion\",\n\t\t\" quinquatrigintillion\",\n\t\t\" sestrigintillion\",\n\t\t\" septentrigintillion\",\n\t\t\" octotrigintillion\",\n\t\t\" noventrigintillion\",\n\t\t\" quadragintillion\",\n\t\t\" unquadragintillion\",\n\t\t\" duoquadragintillion\",\n\t\t\" tresquadragintillion\",\n\t\t\" quattuorquadragintillion\",\n\t\t\" quinquaquadragintillion\",\n\t\t\" sesquadragintillion\",\n\t\t\" septenquadragintillion\",\n\t\t\" octoquadragintillion\",\n\t\t\" novenquadragintillion\",\n\t\t\" quinquagintillion\",\n\t\t\" unquinquagintillion\",\n\t\t\" duoquinquagintillion\",\n\t\t\" tresquinquagintillion\",\n\t\t\" quattuorquinquagintillion\",\n\t\t\" quinquaquinquagintillion\",\n\t\t\" sesquinquagintillion\",\n\t\t\" septenquinquagintillion\",\n\t\t\" octoquinquagintillion\",\n\t\t\" novenquinquagintillion\",\n\t\t\" sexagintillion\",\n\t\t\" unsexagintillion\",\n\t\t\" duosexagintillion\",\n\t\t\" tresexagintillion\",\n\t\t\" quattuorsexagintillion\",\n\t\t\" quinquasexagintillion\",\n\t\t\" sesexagintillion\",\n\t\t\" septensexagintillion\",\n\t\t\" octosexagintillion\",\n\t\t\" novensexagintillion\",\n\t\t\" septuagintillion\",\n\t\t\" unseptuagintillion\",\n\t\t\" duoseptuagintillion\",\n\t\t\" treseptuagintillion\",\n\t\t\" quattuorseptuagintillion\",\n\t\t\" quinquaseptuagintillion\",\n\t\t\" seseptuagintillion\",\n\t\t\" septenseptuagintillion\",\n\t\t\" octoseptuagintillion\",\n\t\t\" novenseptuagintillion\",\n\t\t\" octogintillion\",\n\t\t\" unoctogintillion\",\n\t\t\" duooctogintillion\"\n\t]\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// swarm-numberformat.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fddd44a542f0678b992a","// Can't comment a .json file, but the suffixes come from these pages:\n// http://home.kpn.nl/vanadovv/BignumbyN.html\nimport standardSuffixes from './standard-suffixes.json'\nimport longScaleSuffixes from './long-scale-suffixes.json'\n\nfunction log(...mess) {\n  //console.log(...mess)\n}\n// Lazy-load - we might not need decimal. It's a peerDependency, so the parent\n// library must include it if needed - we don't, because many callers don't need\n// it.\nlet Decimal\nfunction requireDecimal() {\n  return Decimal || (Decimal = (function() {\n    if (global && global.Decimal) {\n      log('swarm-numberformat decimal.js: Found global.Decimal')\n      return global.Decimal\n    }\n    if (global && global.window && window.Decimal) {\n      log('swarm-numberformat decimal.js: Found window.Decimal')\n      return window.Decimal\n    }\n    log('swarm-numberformat decimal.js: trying require()')\n    return require('decimal.js')\n  })())\n}\n// TODO: use this page to generate names dynamically, for even larger numbers:\n//   http://mathforum.org/library/drmath/view/59154.html\n\nfunction validate(condition, message) {\n  if (!condition) {\n    throw new Error(message)\n  }\n  return condition\n}\n\n// polyfill IE and phantomjs\nconst log10 = (() => {\n  if (!!Math.log10) {\n    return Math.log10\n  }\n  return function(val) {\n    let ret = Math.log(val) / Math.LN10;\n    // bloody stupid rounding errors\n    ret = Math.round(ret * 1e6) / 1e6\n    return ret\n  }\n})()\n\nconst backends = {\n  'native': {\n    normalize(val) {\n      return val\n    },\n    // Suffixes are a list - which index of the list do we want?\n    // _index(999) === 0\n    // _index(1000) === 1\n    // _index(1000000) === 2\n    index(val) {\n      // string length is faster but fails for length >= 20, where JS starts\n      // formatting with e\n      return Math.max(0, Math.floor(log10(Math.abs(val))/3))\n    },\n    prefix(val, index, {sigfigs}) {\n      // `sigfigs||undefined` supports sigfigs=[null|0], #15\n      return (val / Math.pow(1000, index)).toPrecision(sigfigs || undefined)\n    },\n  },\n  'decimal.js': {\n    // api docs: https://mikemcl.github.io/decimal.js/\n    _requireDecimal(config) {\n      if (!requireDecimal()) throw new Error('requireDecimal() failed')\n      return new requireDecimal()(0).constructor.clone(config)\n    },\n    normalize(val, {rounding}) {\n      const Decimal = this._requireDecimal({rounding})\n      return new Decimal(val)\n    },\n    index(val) {\n      const Decimal = this._requireDecimal()\n      // index = val.log10().dividedToIntegerBy(Decimal.log 1000)\n      // Decimal.log() is too slow for large numbers. Docs say performance degrades exponentially as # digits increases, boo.\n      // Lucky me, the length is used by decimal.js internally: num.e\n      // this is in the docs, so I think it's stable enough to use...\n      val = new Decimal(val)\n      return Math.floor(val.e / 3)\n    },\n    prefix(val, index, {sigfigs, rounding}) {\n      const Decimal = this._requireDecimal({rounding})\n      var div = new Decimal(1000).pow(index)\n      // `sigfigs||undefined` supports sigfigs=[null|0], #15\n      return new Decimal(val).dividedBy(div).toPrecision(sigfigs || undefined)\n    },\n  },\n}\n\n// The formatting function.\nfunction _format(val, opts) {\n  const backend = validate(backends[opts.backend], `not a backend: ${opts.backend}`)\n  val = backend.normalize(val, opts)\n  const index = backend.index(val)\n  const suffix = opts.suffixFn(index)\n  // `{sigfigs: undefined|null|0}` for automatic sigfigs is supported.\n  let sigfigs = opts.sigfigs || undefined\n  // optionally format small numbers differently: show decimals without trailing zeros\n  if (Math.abs(val) < opts.maxSmall) {\n    // second param for decimal.js only, native ignores it\n    return val.toPrecision(sigfigs, opts.rounding).replace(/(\\.\\d*[1-9])0+$/, '$1')\n  }\n  // opts.minSuffix: Use JS native formatting for smallish numbers, because\n  // '99,999' is prettier than '99.9k'\n  // it's safe to let Math coerce Decimal.js to infinity here, gt/lt still work\n  if (Math.abs(val) < opts.minSuffix) {\n    val = Math.floor(val)\n    return val.toLocaleString()\n  }\n  // No suffix found: use scientific notation. JS's native toExponential is fine.\n  if (!suffix && suffix !== '') {\n    if (!!sigfigs) {\n      sigfigs -= 1\n    }\n    return val.toExponential(sigfigs).replace('e+', 'e')\n  }\n  // Found a suffix. Calculate the prefix, the number before the suffix.\n  const prefix = backend.prefix(val, index, opts)\n  return `${prefix}${suffix}`\n}\n\nconst defaultOptions = {\n  backend: 'native',\n  flavor: 'full',\n  suffixGroup: 'full',\n  suffixFn(index) {\n    var suffixes = this.suffixes || this.suffixGroups[this.suffixGroup]\n    validate(suffixes, `no such suffixgroup: ${this.suffixGroup}`)\n    if (index < suffixes.length) {\n      return suffixes[index] || ''\n    }\n    // return undefined\n  },\n  // minimum value to use any suffix, because '99,900' is prettier than '99.9k'\n  minSuffix: 1e5,\n  // don't use sigfigs for smallish numbers. #13\n  minSuffixSigfigs: false,\n  // Special formatting for numbers with a decimal point\n  maxSmall: 0,\n  sigfigs: 3, // often overridden by flavor\n  format: 'standard'\n}\n// User-visible format choices, like on swarmsim's options screen.\n// Each has a different set of options.\nexport const Formats = {\n  standard: {suffixGroups: standardSuffixes},\n  // like standard formatting, with a different set of suffixes\n  longScale: {suffixGroups: longScaleSuffixes},\n  // like standard formatting, with no suffixes at all\n  scientific: {suffixGroups: {full: [], short: []}},\n  // like standard formatting, with a smaller set of suffixes\n  hybrid: {\n    suffixGroups: {\n      full: standardSuffixes.full.slice(0, 12),\n      short: standardSuffixes.short.slice(0, 12),\n    },\n  },\n  // like standard formatting, with a different/infinite set of suffixes\n  engineering: {suffixFn: index => index === 0 ? '' : `E${index*3}`},\n}\n// A convenient way for the developer to modify formatters.\n// These are different from formats - not user-visible.\nconst Flavors = {\n  full: {suffixGroup: 'full', sigfigs: 5},\n  short: {suffixGroup: 'short', sigfigs: 3},\n}\n// Allow callers to extend formats and flavors.\ndefaultOptions.formats = Formats\ndefaultOptions.flavors = Flavors\n\nexport class Formatter {\n  /**\n   * @param {Object} opts All formatter configuration.\n   * @param {string} [opts.flavor='full'] 'full' or 'short'. Flavors can modify any number of other options here. Full is the default; short has fewer sigfigs and shorter standard-suffixes.\n   * @param {Object} [opts.flavors] Specify your own custom flavors.\n   * @param {string} [opts.backend='native'] 'native' or 'decimal.js'.\n   * @param {string} [opts.suffixGroup]\n   * @param {Function} [opts.suffixFn]\n   * @param {number} [opts.minSuffix=1e5]\n   * @param {number} [opts.maxSmall=0] Special formatting for numbers with a decimal point\n   * @param {number} [opts.sigfigs=5]\n   * @param {number} [opts.format='standard'] 'standard', 'hybrid', 'scientific', 'longScale'.\n   * @param {Object} [opts.formats] Specify your own custom formats.\n   */\n  constructor(opts = {}) {\n    /** @type Object */\n    this.opts = opts\n    // create convenience methods for each flavor\n    var flavors = Object.keys(this._normalizeOpts().flavors)\n    // the fn(i) is for stupid binding tricks with the looped fn(val, opts)\n    for (var i=0; i < flavors.length; i++) (i => {\n      var flavor = flavors[i]\n      // capitalize the first letter to camel-case method name, like formatShort\n      var key = 'format' + flavor.charAt(0).toUpperCase() + flavor.substr(1)\n      /** @ignore */\n      this[key] = (val, opts) => this.formatFlavor(val, flavor, opts)\n    })(i)\n  }\n\n  _normalizeOpts(opts={}) {\n    // all the user-specified opts, no defaults\n    opts = Object.assign({}, this.opts, opts)\n    // opts.format redefines some other opts, but should never override the user's opts\n    var format = opts && opts.format\n    var formats = (opts && opts.formats) || defaultOptions.formats\n    var formatOptions = formats[format || defaultOptions.format]\n    validate(formatOptions, `no such format: ${format}`)\n    var flavor = opts && opts.flavor\n    var flavors = (opts && opts.flavors) || defaultOptions.flavors\n    var flavorOptions = flavors[flavor || defaultOptions.flavor]\n    validate(flavorOptions, `no such flavor: ${flavor}`)\n    // finally, add the implied options: defaults and format-derived\n    return Object.assign({}, defaultOptions, formatOptions, flavorOptions, opts)\n  }\n  /**\n   * @param {number} val\n   * @param {Object} [opts]\n   * @return {number} which suffix to use for this number in a list of suffixes. You can also think of this as \"how many commas are in the number?\"\n   */\n  index(val, opts) {\n    opts = this._normalizeOpts(opts)\n    return backends[opts.backend].index(val)\n  }\n  /**\n   * @param {number} val\n   * @param {Object} [opts]\n   * @return {string} The suffix that this number would use, with no number shown.\n   * @example\n   * new Formatter().suffix(1e6)\n   * // => \" million\"\n   * @example\n   * new Formatter().suffix(1e6, {flavor: \"short\"})\n   * // => \"M\"\n   */\n  suffix(val, opts) {\n    opts = this._normalizeOpts(opts)\n    var index = backends[opts.backend].index(val)\n    return opts.suffixFn(index)\n  }\n  /**\n   * Format a number.\n   * @param {number} val\n   * @param {Object} [opts] Override the options provided to the Formatter constructor.\n   * @return {string} The formatted number.\n   * @example\n   * new Formatter().format(1e6)\n   * // => \"1.0000 million\"\n   */\n  format(val, opts) {\n    opts = this._normalizeOpts(opts)\n    return _format(val, opts)\n  }\n  /**\n   * Format a number with a specified flavor. It's very common to call the formatter with different flavors, so it has its own shortcut.\n   *\n   * `Formatter.formatFull()` and `Formatter.formatShort()` are also available.\n   * @param {number} val\n   * @param {string} flavor 'short' or 'full'. See opts.flavor.\n   * @param {Object} [opts]\n   * @return {string} The formatted number.\n   * @example\n   * new Formatter().format(1e6, 'short')\n   * // => \"1.00M\"\n   */\n  formatFlavor(val, flavor, opts) {\n    return this.format(val, Object.assign({}, opts, {flavor}))\n  }\n  /**\n   * @param {Object} [opts]\n   * @return {string[]} The complete list of formats available. Use this to build an options UI to allow your players to choose their favorite format.\n   */\n  listFormats(opts) {\n    opts = this._normalizeOpts(opts)\n    return Object.keys(opts.formats)\n  }\n}\n\nconst numberformat = new Formatter()\nnumberformat.defaultOptions = defaultOptions\nnumberformat.Formatter = Formatter\nexport default numberformat\n\n/**\n * Format a number using the default options.\n * @param {number} val\n * @param {Object} [opts]\n * @return string\n * @example\n * format(1e6)\n * // => \"1.0000 million\"\n * @example\n * format(1e6, {sigfigs: 1})\n * // => \"1 million\"\n */\nexport const format = (val, opts) => numberformat.format(val, opts)\n/**\n * Format a full-flavor number using the default options. Identical to `format()`\n * @param {number} val\n * @param {Object} [opts]\n * @return string\n * @example\n * format(1e6)\n * // => \"1.0000 million\"\n */\nexport const formatFull = (val, opts) => numberformat.formatFlavor(val, 'full', opts)\n/**\n * Format a short-flavor number using the default options.\n * @param {number} val\n * @param {Object} [opts]\n * @return string\n * @example\n * format(1e6)\n * // => \"1.00M\"\n */\nexport const formatShort = (val, opts) => numberformat.formatFlavor(val, 'short', opts)\n\n\n\n// WEBPACK FOOTER //\n// ./src/format.js","/*\r\n *\r\n *  decimal.js v7.2.1\r\n *  An arbitrary-precision Decimal type for JavaScript.\r\n *  https://github.com/MikeMcl/decimal.js\r\n *  Copyright (c) 2017 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  MIT Licence\r\n *  https://github.com/MikeMcl/decimal.js/LICENCE\r\n *\r\n */\r\n\r\n\r\n// -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n  // The maximum exponent magnitude.\r\n  // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\nvar EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n  // The limit on the value of `precision`, and on the value of the first argument to\r\n  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n  MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n  // Base conversion alphabet.\r\n  NUMERALS = '0123456789abcdef',\r\n\r\n  // The natural logarithm of 10 (1025 digits).\r\n  ln10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n  // Pi (1025 digits).\r\n  pi = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n  // The initial configuration properties of the Decimal constructor.\r\n  defaults = {\r\n\r\n    // These values must be integers within the stated ranges (inclusive).\r\n    // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n    // The maximum number of significant digits of the result of a calculation or base conversion.\r\n    // E.g. `Decimal.config({ precision: 20 });`\r\n    precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n    // The rounding mode used when rounding to `precision`.\r\n    //\r\n    // ROUND_UP         0 Away from zero.\r\n    // ROUND_DOWN       1 Towards zero.\r\n    // ROUND_CEIL       2 Towards +Infinity.\r\n    // ROUND_FLOOR      3 Towards -Infinity.\r\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    //\r\n    // E.g.\r\n    // `Decimal.rounding = 4;`\r\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n    rounding: 4,                           // 0 to 8\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n    // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN  6 The IEEE 754 remainder function.\r\n    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n    //\r\n    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n    // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n    // be used, but they may not give useful results.\r\n    modulo: 1,                             // 0 to 9\r\n\r\n    // The exponent value at and beneath which `toString` returns exponential notation.\r\n    // JavaScript numbers: -7\r\n    toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n    // The exponent value at and above which `toString` returns exponential notation.\r\n    // JavaScript numbers: 21\r\n    toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // JavaScript numbers: -324  (5e-324)\r\n    minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n    maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    crypto: false                          // true/false\r\n  },\r\n\r\n\r\n// ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n  Decimal, LN10, PI, inexact, quadrant,\r\n  external = true,\r\n\r\n  decimalError = '[DecimalError] ',\r\n  invalidArgument = decimalError + 'Invalid argument: ',\r\n  precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n  cryptoUnavailable = decimalError + 'crypto unavailable',\r\n\r\n  mathfloor = Math.floor,\r\n  mathpow = Math.pow,\r\n\r\n  isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n  isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n  isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n  isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n  BASE = 1e7,\r\n  LOG_BASE = 7,\r\n  MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n  LN10_PRECISION = ln10.length - 1,\r\n  PI_PRECISION = pi.length - 1,\r\n\r\n  // Decimal.prototype object\r\n  P = {};\r\n\r\n\r\n// Decimal prototype methods\r\n\r\n\r\n/*\r\n *  absoluteValue             abs\r\n *  ceil\r\n *  comparedTo                cmp\r\n *  cosine                    cos\r\n *  cubeRoot                  cbrt\r\n *  decimalPlaces             dp\r\n *  dividedBy                 div\r\n *  dividedToIntegerBy        divToInt\r\n *  equals                    eq\r\n *  floor\r\n *  greaterThan               gt\r\n *  greaterThanOrEqualTo      gte\r\n *  hyperbolicCosine          cosh\r\n *  hyperbolicSine            sinh\r\n *  hyperbolicTangent         tanh\r\n *  inverseCosine             acos\r\n *  inverseHyperbolicCosine   acosh\r\n *  inverseHyperbolicSine     asinh\r\n *  inverseHyperbolicTangent  atanh\r\n *  inverseSine               asin\r\n *  inverseTangent            atan\r\n *  isFinite\r\n *  isInteger                 isInt\r\n *  isNaN\r\n *  isNegative                isNeg\r\n *  isPositive                isPos\r\n *  isZero\r\n *  lessThan                  lt\r\n *  lessThanOrEqualTo         lte\r\n *  logarithm                 log\r\n *  [maximum]                 [max]\r\n *  [minimum]                 [min]\r\n *  minus                     sub\r\n *  modulo                    mod\r\n *  naturalExponential        exp\r\n *  naturalLogarithm          ln\r\n *  negated                   neg\r\n *  plus                      add\r\n *  precision                 sd\r\n *  round\r\n *  sine                      sin\r\n *  squareRoot                sqrt\r\n *  tangent                   tan\r\n *  times                     mul\r\n *  toBinary\r\n *  toDecimalPlaces           toDP\r\n *  toExponential\r\n *  toFixed\r\n *  toFraction\r\n *  toHexadecimal             toHex\r\n *  toNearest\r\n *  toNumber\r\n *  toOctal\r\n *  toPower                   pow\r\n *  toPrecision\r\n *  toSignificantDigits       toSD\r\n *  toString\r\n *  truncated                 trunc\r\n *  valueOf                   toJSON\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the absolute value of this Decimal.\r\n *\r\n */\r\nP.absoluteValue = P.abs = function () {\r\n  var x = new this.constructor(this);\r\n  if (x.s < 0) x.s = 1;\r\n  return finalise(x);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of positive Infinity.\r\n *\r\n */\r\nP.ceil = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 2);\r\n};\r\n\r\n\r\n/*\r\n * Return\r\n *   1    if the value of this Decimal is greater than the value of `y`,\r\n *  -1    if the value of this Decimal is less than the value of `y`,\r\n *   0    if they have the same value,\r\n *   NaN  if the value of either Decimal is NaN.\r\n *\r\n */\r\nP.comparedTo = P.cmp = function (y) {\r\n  var i, j, xdL, ydL,\r\n    x = this,\r\n    xd = x.d,\r\n    yd = (y = new x.constructor(y)).d,\r\n    xs = x.s,\r\n    ys = y.s;\r\n\r\n  // Either NaN or Infinity?\r\n  if (!xd || !yd) {\r\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n  }\r\n\r\n  // Either zero?\r\n  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n  // Signs differ?\r\n  if (xs !== ys) return xs;\r\n\r\n  // Compare exponents.\r\n  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n  xdL = xd.length;\r\n  ydL = yd.length;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n  }\r\n\r\n  // Compare lengths.\r\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * cos(0)         = 1\r\n * cos(-0)        = 1\r\n * cos(Infinity)  = NaN\r\n * cos(-Infinity) = NaN\r\n * cos(NaN)       = NaN\r\n *\r\n */\r\nP.cosine = P.cos = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.d) return new Ctor(NaN);\r\n\r\n  // cos(0) = cos(-0) = 1\r\n  if (!x.d[0]) return new Ctor(1);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n  Ctor.rounding = 1;\r\n\r\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n *\r\n * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n *  cbrt(0)  =  0\r\n *  cbrt(-0) = -0\r\n *  cbrt(1)  =  1\r\n *  cbrt(-1) = -1\r\n *  cbrt(N)  =  N\r\n *  cbrt(-I) = -I\r\n *  cbrt(I)  =  I\r\n *\r\n * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n *\r\n */\r\nP.cubeRoot = P.cbrt = function () {\r\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n  external = false;\r\n\r\n  // Initial estimate.\r\n  s = x.s * Math.pow(x.s * x, 1 / 3);\r\n\r\n   // Math.cbrt underflow/overflow?\r\n   // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n  if (!s || Math.abs(s) == 1 / 0) {\r\n    n = digitsToString(x.d);\r\n    e = x.e;\r\n\r\n    // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n    s = Math.pow(n, 1 / 3);\r\n\r\n    // Rarely, e may be one less than the result exponent value.\r\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n    if (s == 1 / 0) {\r\n      n = '5e' + e;\r\n    } else {\r\n      n = s.toExponential();\r\n      n = n.slice(0, n.indexOf('e') + 1) + e;\r\n    }\r\n\r\n    r = new Ctor(n);\r\n    r.s = x.s;\r\n  } else {\r\n    r = new Ctor(s.toString());\r\n  }\r\n\r\n  sd = (e = Ctor.precision) + 3;\r\n\r\n  // Halley's method.\r\n  // TODO? Compare Newton's method.\r\n  for (;;) {\r\n    t = r;\r\n    t3 = t.times(t).times(t);\r\n    t3plusx = t3.plus(x);\r\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n    // TODO? Replace with for-loop and checkRoundingDigits.\r\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n      n = n.slice(sd - 3, sd + 1);\r\n\r\n      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n      // , i.e. approaching a rounding boundary, continue the iteration.\r\n      if (n == '9999' || !rep && n == '4999') {\r\n\r\n        // On the first iteration only, check to see if rounding up gives the exact result as the\r\n        // nines may infinitely repeat.\r\n        if (!rep) {\r\n          finalise(t, e + 1, 0);\r\n\r\n          if (t.times(t).times(t).eq(x)) {\r\n            r = t;\r\n            break;\r\n          }\r\n        }\r\n\r\n        sd += 4;\r\n        rep = 1;\r\n      } else {\r\n\r\n        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n        // If not, then there are further digits and m will be truthy.\r\n        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n          // Truncate to the first rounding digit.\r\n          finalise(r, e + 1, 1);\r\n          m = !r.times(r).times(r).eq(x);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, e, Ctor.rounding, m);\r\n};\r\n\r\n\r\n/*\r\n * Return the number of decimal places of the value of this Decimal.\r\n *\r\n */\r\nP.decimalPlaces = P.dp = function () {\r\n  var w,\r\n    d = this.d,\r\n    n = NaN;\r\n\r\n  if (d) {\r\n    w = d.length - 1;\r\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last word.\r\n    w = d[w];\r\n    if (w) for (; w % 10 == 0; w /= 10) n--;\r\n    if (n < 0) n = 0;\r\n  }\r\n\r\n  return n;\r\n};\r\n\r\n\r\n/*\r\n *  n / 0 = I\r\n *  n / N = N\r\n *  n / I = 0\r\n *  0 / n = 0\r\n *  0 / 0 = N\r\n *  0 / N = N\r\n *  0 / I = 0\r\n *  N / n = N\r\n *  N / 0 = N\r\n *  N / N = N\r\n *  N / I = N\r\n *  I / n = I\r\n *  I / 0 = I\r\n *  I / N = N\r\n *  I / I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.dividedBy = P.div = function (y) {\r\n  return divide(this, new this.constructor(y));\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.dividedToIntegerBy = P.divToInt = function (y) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n *\r\n */\r\nP.equals = P.eq = function (y) {\r\n  return this.cmp(y) === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of negative Infinity.\r\n *\r\n */\r\nP.floor = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 3);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n * false.\r\n *\r\n */\r\nP.greaterThan = P.gt = function (y) {\r\n  return this.cmp(y) > 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n * otherwise return false.\r\n *\r\n */\r\nP.greaterThanOrEqualTo = P.gte = function (y) {\r\n  var k = this.cmp(y);\r\n  return k == 1 || k === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [1, Infinity]\r\n *\r\n * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n *\r\n * cosh(0)         = 1\r\n * cosh(-0)        = 1\r\n * cosh(Infinity)  = Infinity\r\n * cosh(-Infinity) = Infinity\r\n * cosh(NaN)       = NaN\r\n *\r\n *  x        time taken (ms)   result\r\n * 1000      9                 9.8503555700852349694e+433\r\n * 10000     25                4.4034091128314607936e+4342\r\n * 100000    171               1.4033316802130615897e+43429\r\n * 1000000   3817              1.5166076984010437725e+434294\r\n * 10000000  abandoned after 2 minute wait\r\n *\r\n * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n *\r\n */\r\nP.hyperbolicCosine = P.cosh = function () {\r\n  var k, n, pr, rm, len,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    one = new Ctor(1);\r\n\r\n  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n  if (x.isZero()) return one;\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  len = x.d.length;\r\n\r\n  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  // TODO? Estimation reused from cosine() and may not be optimal here.\r\n  if (len < 32) {\r\n    k = Math.ceil(len / 3);\r\n    n = Math.pow(4, -k).toString();\r\n  } else {\r\n    k = 16;\r\n    n = '2.3283064365386962890625e-10';\r\n  }\r\n\r\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n  // Reverse argument reduction\r\n  var cosh2_x,\r\n    i = k,\r\n    d8 = new Ctor(8);\r\n  for (; i--;) {\r\n    cosh2_x = x.times(x);\r\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n  }\r\n\r\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n *\r\n * sinh(0)         = 0\r\n * sinh(-0)        = -0\r\n * sinh(Infinity)  = Infinity\r\n * sinh(-Infinity) = -Infinity\r\n * sinh(NaN)       = NaN\r\n *\r\n * x        time taken (ms)\r\n * 10       2 ms\r\n * 100      5 ms\r\n * 1000     14 ms\r\n * 10000    82 ms\r\n * 100000   886 ms            1.4033316802130615897e+43429\r\n * 200000   2613 ms\r\n * 300000   5407 ms\r\n * 400000   8824 ms\r\n * 500000   13026 ms          8.7080643612718084129e+217146\r\n * 1000000  48543 ms\r\n *\r\n * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n *\r\n */\r\nP.hyperbolicSine = P.sinh = function () {\r\n  var k, pr, rm, len,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  len = x.d.length;\r\n\r\n  if (len < 3) {\r\n    x = taylorSeries(Ctor, 2, x, x, true);\r\n  } else {\r\n\r\n    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n    // 3 multiplications and 1 addition\r\n\r\n    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n    // 4 multiplications and 2 additions\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(Math.pow(5, -k));\r\n\r\n    x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n    // Reverse argument reduction\r\n    var sinh2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sinh2_x = x.times(x);\r\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n    }\r\n  }\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * tanh(x) = sinh(x) / cosh(x)\r\n *\r\n * tanh(0)         = 0\r\n * tanh(-0)        = -0\r\n * tanh(Infinity)  = 1\r\n * tanh(-Infinity) = -1\r\n * tanh(NaN)       = NaN\r\n *\r\n */\r\nP.hyperbolicTangent = P.tanh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(x.s);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 7;\r\n  Ctor.rounding = 1;\r\n\r\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n * this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [0, pi]\r\n *\r\n * acos(x) = pi/2 - asin(x)\r\n *\r\n * acos(0)       = pi/2\r\n * acos(-0)      = pi/2\r\n * acos(1)       = 0\r\n * acos(-1)      = pi\r\n * acos(1/2)     = pi/3\r\n * acos(-1/2)    = 2*pi/3\r\n * acos(|x| > 1) = NaN\r\n * acos(NaN)     = NaN\r\n *\r\n */\r\nP.inverseCosine = P.acos = function () {\r\n  var halfPi,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    k = x.abs().cmp(1),\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding;\r\n\r\n  if (k !== -1) {\r\n    return k === 0\r\n      // |x| is 1\r\n      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n      // |x| > 1 or x is NaN\r\n      : new Ctor(NaN);\r\n  }\r\n\r\n  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n  Ctor.precision = pr + 6;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.asin();\r\n  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return halfPi.minus(x);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [1, Infinity]\r\n * Range: [0, Infinity]\r\n *\r\n * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n *\r\n * acosh(x < 1)     = NaN\r\n * acosh(NaN)       = NaN\r\n * acosh(Infinity)  = Infinity\r\n * acosh(-Infinity) = NaN\r\n * acosh(0)         = NaN\r\n * acosh(-0)        = NaN\r\n * acosh(1)         = 0\r\n * acosh(-1)        = NaN\r\n *\r\n */\r\nP.inverseHyperbolicCosine = P.acosh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n  if (!x.isFinite()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  external = false;\r\n\r\n  x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n  external = true;\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.ln();\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n *\r\n * asinh(NaN)       = NaN\r\n * asinh(Infinity)  = Infinity\r\n * asinh(-Infinity) = -Infinity\r\n * asinh(0)         = 0\r\n * asinh(-0)        = -0\r\n *\r\n */\r\nP.inverseHyperbolicSine = P.asinh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n  Ctor.rounding = 1;\r\n  external = false;\r\n\r\n  x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n  external = true;\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.ln();\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n *\r\n * atanh(|x| > 1)   = NaN\r\n * atanh(NaN)       = NaN\r\n * atanh(Infinity)  = NaN\r\n * atanh(-Infinity) = NaN\r\n * atanh(0)         = 0\r\n * atanh(-0)        = -0\r\n * atanh(1)         = Infinity\r\n * atanh(-1)        = -Infinity\r\n *\r\n */\r\nP.inverseHyperbolicTangent = P.atanh = function () {\r\n  var pr, rm, wpr, xsd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  xsd = x.sd();\r\n\r\n  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n  Ctor.precision = wpr = xsd - x.e;\r\n\r\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n  Ctor.precision = pr + 4;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.ln();\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.times(0.5);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n *\r\n * asin(0)       = 0\r\n * asin(-0)      = -0\r\n * asin(1/2)     = pi/6\r\n * asin(-1/2)    = -pi/6\r\n * asin(1)       = pi/2\r\n * asin(-1)      = -pi/2\r\n * asin(|x| > 1) = NaN\r\n * asin(NaN)     = NaN\r\n *\r\n * TODO? Compare performance of Taylor series.\r\n *\r\n */\r\nP.inverseSine = P.asin = function () {\r\n  var halfPi, k,\r\n    pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  k = x.abs().cmp(1);\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  if (k !== -1) {\r\n\r\n    // |x| is 1\r\n    if (k === 0) {\r\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n      halfPi.s = x.s;\r\n      return halfPi;\r\n    }\r\n\r\n    // |x| > 1 or x is NaN\r\n    return new Ctor(NaN);\r\n  }\r\n\r\n  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n  Ctor.precision = pr + 6;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.times(2);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n *\r\n * atan(0)         = 0\r\n * atan(-0)        = -0\r\n * atan(1)         = pi/4\r\n * atan(-1)        = -pi/4\r\n * atan(Infinity)  = pi/2\r\n * atan(-Infinity) = -pi/2\r\n * atan(NaN)       = NaN\r\n *\r\n */\r\nP.inverseTangent = P.atan = function () {\r\n  var i, j, k, n, px, t, r, wpr, x2,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding;\r\n\r\n  if (!x.isFinite()) {\r\n    if (!x.s) return new Ctor(NaN);\r\n    if (pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n  } else if (x.isZero()) {\r\n    return new Ctor(x);\r\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n    r.s = x.s;\r\n    return r;\r\n  }\r\n\r\n  Ctor.precision = wpr = pr + 10;\r\n  Ctor.rounding = 1;\r\n\r\n  // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n  // Argument reduction\r\n  // Ensure |x| < 0.42\r\n  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n  external = false;\r\n\r\n  j = Math.ceil(wpr / LOG_BASE);\r\n  n = 1;\r\n  x2 = x.times(x);\r\n  r = new Ctor(x);\r\n  px = x;\r\n\r\n  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n  for (; i !== -1;) {\r\n    px = px.times(x2);\r\n    t = r.minus(px.div(n += 2));\r\n\r\n    px = px.times(x2);\r\n    r = t.plus(px.div(n += 2));\r\n\r\n    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n  }\r\n\r\n  if (k) r = r.times(2 << (k - 1));\r\n\r\n  external = true;\r\n\r\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n *\r\n */\r\nP.isFinite = function () {\r\n  return !!this.d;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is an integer, otherwise return false.\r\n *\r\n */\r\nP.isInteger = P.isInt = function () {\r\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is NaN, otherwise return false.\r\n *\r\n */\r\nP.isNaN = function () {\r\n  return !this.s;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is negative, otherwise return false.\r\n *\r\n */\r\nP.isNegative = P.isNeg = function () {\r\n  return this.s < 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is positive, otherwise return false.\r\n *\r\n */\r\nP.isPositive = P.isPos = function () {\r\n  return this.s > 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n *\r\n */\r\nP.isZero = function () {\r\n  return !!this.d && this.d[0] === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n *\r\n */\r\nP.lessThan = P.lt = function (y) {\r\n  return this.cmp(y) < 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n *\r\n */\r\nP.lessThanOrEqualTo = P.lte = function (y) {\r\n  return this.cmp(y) < 1;\r\n};\r\n\r\n\r\n/*\r\n * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * If no base is specified, return log[10](arg).\r\n *\r\n * log[base](arg) = ln(arg) / ln(base)\r\n *\r\n * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n * otherwise:\r\n *\r\n * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n *\r\n * log[-b](a)       = NaN\r\n * log[0](a)        = NaN\r\n * log[1](a)        = NaN\r\n * log[NaN](a)      = NaN\r\n * log[Infinity](a) = NaN\r\n * log[b](0)        = -Infinity\r\n * log[b](-0)       = -Infinity\r\n * log[b](-a)       = NaN\r\n * log[b](1)        = 0\r\n * log[b](Infinity) = Infinity\r\n * log[b](NaN)      = NaN\r\n *\r\n * [base] {number|string|Decimal} The base of the logarithm.\r\n *\r\n */\r\nP.logarithm = P.log = function (base) {\r\n  var isBase10, d, denominator, k, inf, num, sd, r,\r\n    arg = this,\r\n    Ctor = arg.constructor,\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding,\r\n    guard = 5;\r\n\r\n  // Default base is 10.\r\n  if (base == null) {\r\n    base = new Ctor(10);\r\n    isBase10 = true;\r\n  } else {\r\n    base = new Ctor(base);\r\n    d = base.d;\r\n\r\n    // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n    isBase10 = base.eq(10);\r\n  }\r\n\r\n  d = arg.d;\r\n\r\n  // Is arg negative, non-finite, 0 or 1?\r\n  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n  }\r\n\r\n  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n  // integer power of 10.\r\n  if (isBase10) {\r\n    if (d.length > 1) {\r\n      inf = true;\r\n    } else {\r\n      for (k = d[0]; k % 10 === 0;) k /= 10;\r\n      inf = k !== 1;\r\n    }\r\n  }\r\n\r\n  external = false;\r\n  sd = pr + guard;\r\n  num = naturalLogarithm(arg, sd);\r\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n  // The result will have 5 rounding digits.\r\n  r = divide(num, denominator, sd, 1);\r\n\r\n  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n  // calculate 10 further digits.\r\n  //\r\n  // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n  // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n  // further digits, the last 14 are nines, round up and assume the result is exact.\r\n  // Also assume the result is exact if the last 14 are zero.\r\n  //\r\n  // Example of a result that will be incorrectly rounded:\r\n  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n  // place is still 2.6.\r\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n    do {\r\n      sd += 10;\r\n      num = naturalLogarithm(arg, sd);\r\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n      r = divide(num, denominator, sd, 1);\r\n\r\n      if (!inf) {\r\n\r\n        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n\r\n        break;\r\n      }\r\n    } while (checkRoundingDigits(r.d, k += 10, rm));\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, pr, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.max = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'lt');\r\n};\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.min = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'gt');\r\n};\r\n */\r\n\r\n\r\n/*\r\n *  n - 0 = n\r\n *  n - N = N\r\n *  n - I = -I\r\n *  0 - n = -n\r\n *  0 - 0 = 0\r\n *  0 - N = N\r\n *  0 - I = -I\r\n *  N - n = N\r\n *  N - 0 = N\r\n *  N - N = N\r\n *  N - I = N\r\n *  I - n = I\r\n *  I - 0 = I\r\n *  I - N = N\r\n *  I - I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.minus = P.sub = function (y) {\r\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // If either is not finite...\r\n  if (!x.d || !y.d) {\r\n\r\n    // Return NaN if either is NaN.\r\n    if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n    // Return y negated if x is finite and y is Infinity.\r\n    else if (x.d) y.s = -y.s;\r\n\r\n    // Return x if y is finite and x is Infinity.\r\n    // Return x if both are Infinity with different signs.\r\n    // Return NaN if both are Infinity with the same sign.\r\n    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n    return y;\r\n  }\r\n\r\n  // If signs differ...\r\n  if (x.s != y.s) {\r\n    y.s = -y.s;\r\n    return x.plus(y);\r\n  }\r\n\r\n  xd = x.d;\r\n  yd = y.d;\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  // If either is zero...\r\n  if (!xd[0] || !yd[0]) {\r\n\r\n    // Return y negated if x is zero and y is non-zero.\r\n    if (yd[0]) y.s = -y.s;\r\n\r\n    // Return x if y is zero and x is non-zero.\r\n    else if (xd[0]) y = new Ctor(x);\r\n\r\n    // Return zero if both are zero.\r\n    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n    else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  }\r\n\r\n  // x and y are finite, non-zero numbers with the same sign.\r\n\r\n  // Calculate base 1e7 exponents.\r\n  e = mathfloor(y.e / LOG_BASE);\r\n  xe = mathfloor(x.e / LOG_BASE);\r\n\r\n  xd = xd.slice();\r\n  k = xe - e;\r\n\r\n  // If base 1e7 exponents differ...\r\n  if (k) {\r\n    xLTy = k < 0;\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      k = -k;\r\n      len = yd.length;\r\n    } else {\r\n      d = yd;\r\n      e = xe;\r\n      len = xd.length;\r\n    }\r\n\r\n    // Numbers with massively different exponents would result in a very high number of\r\n    // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n    if (k > i) {\r\n      k = i;\r\n      d.length = 1;\r\n    }\r\n\r\n    // Prepend zeros to equalise exponents.\r\n    d.reverse();\r\n    for (i = k; i--;) d.push(0);\r\n    d.reverse();\r\n\r\n  // Base 1e7 exponents equal.\r\n  } else {\r\n\r\n    // Check digits to determine which is the bigger number.\r\n\r\n    i = xd.length;\r\n    len = yd.length;\r\n    xLTy = i < len;\r\n    if (xLTy) len = i;\r\n\r\n    for (i = 0; i < len; i++) {\r\n      if (xd[i] != yd[i]) {\r\n        xLTy = xd[i] < yd[i];\r\n        break;\r\n      }\r\n    }\r\n\r\n    k = 0;\r\n  }\r\n\r\n  if (xLTy) {\r\n    d = xd;\r\n    xd = yd;\r\n    yd = d;\r\n    y.s = -y.s;\r\n  }\r\n\r\n  len = xd.length;\r\n\r\n  // Append zeros to `xd` if shorter.\r\n  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n  // Subtract yd from xd.\r\n  for (i = yd.length; i > k;) {\r\n\r\n    if (xd[--i] < yd[i]) {\r\n      for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n      --xd[j];\r\n      xd[i] += BASE;\r\n    }\r\n\r\n    xd[i] -= yd[i];\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  for (; xd[--len] === 0;) xd.pop();\r\n\r\n  // Remove leading zeros and adjust exponent accordingly.\r\n  for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n  // Zero?\r\n  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n  y.d = xd;\r\n  y.e = getBase10Exponent(xd, e);\r\n\r\n  return external ? finalise(y, pr, rm) : y;\r\n};\r\n\r\n\r\n/*\r\n *   n % 0 =  N\r\n *   n % N =  N\r\n *   n % I =  n\r\n *   0 % n =  0\r\n *  -0 % n = -0\r\n *   0 % 0 =  N\r\n *   0 % N =  N\r\n *   0 % I =  0\r\n *   N % n =  N\r\n *   N % 0 =  N\r\n *   N % N =  N\r\n *   N % I =  N\r\n *   I % n =  N\r\n *   I % 0 =  N\r\n *   I % N =  N\r\n *   I % I =  N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * The result depends on the modulo mode.\r\n *\r\n */\r\nP.modulo = P.mod = function (y) {\r\n  var q,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // Return NaN if x is Infinity or NaN, or y is NaN or 0.\r\n  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n  // Return x if y is Infinity or x is 0.\r\n  if (!y.d || x.d && !x.d[0]) {\r\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n  }\r\n\r\n  // Prevent rounding of intermediate calculations.\r\n  external = false;\r\n\r\n  if (Ctor.modulo == 9) {\r\n\r\n    // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n    // result = x - q * y    where  0 <= result < abs(y)\r\n    q = divide(x, y.abs(), 0, 3, 1);\r\n    q.s *= y.s;\r\n  } else {\r\n    q = divide(x, y, 0, Ctor.modulo, 1);\r\n  }\r\n\r\n  q = q.times(y);\r\n\r\n  external = true;\r\n\r\n  return x.minus(q);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.naturalExponential = P.exp = function () {\r\n  return naturalExponential(this);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.naturalLogarithm = P.ln = function () {\r\n  return naturalLogarithm(this);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n * -1.\r\n *\r\n */\r\nP.negated = P.neg = function () {\r\n  var x = new this.constructor(this);\r\n  x.s = -x.s;\r\n  return finalise(x);\r\n};\r\n\r\n\r\n/*\r\n *  n + 0 = n\r\n *  n + N = N\r\n *  n + I = I\r\n *  0 + n = n\r\n *  0 + 0 = 0\r\n *  0 + N = N\r\n *  0 + I = I\r\n *  N + n = N\r\n *  N + 0 = N\r\n *  N + N = N\r\n *  N + I = N\r\n *  I + n = I\r\n *  I + 0 = I\r\n *  I + N = N\r\n *  I + I = I\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.plus = P.add = function (y) {\r\n  var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // If either is not finite...\r\n  if (!x.d || !y.d) {\r\n\r\n    // Return NaN if either is NaN.\r\n    if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n    // Return x if y is finite and x is Infinity.\r\n    // Return x if both are Infinity with the same sign.\r\n    // Return NaN if both are Infinity with different signs.\r\n    // Return y if x is finite and y is Infinity.\r\n    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n    return y;\r\n  }\r\n\r\n   // If signs differ...\r\n  if (x.s != y.s) {\r\n    y.s = -y.s;\r\n    return x.minus(y);\r\n  }\r\n\r\n  xd = x.d;\r\n  yd = y.d;\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  // If either is zero...\r\n  if (!xd[0] || !yd[0]) {\r\n\r\n    // Return x if y is zero.\r\n    // Return y if y is non-zero.\r\n    if (!yd[0]) y = new Ctor(x);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  }\r\n\r\n  // x and y are finite, non-zero numbers with the same sign.\r\n\r\n  // Calculate base 1e7 exponents.\r\n  k = mathfloor(x.e / LOG_BASE);\r\n  e = mathfloor(y.e / LOG_BASE);\r\n\r\n  xd = xd.slice();\r\n  i = k - e;\r\n\r\n  // If base 1e7 exponents differ...\r\n  if (i) {\r\n\r\n    if (i < 0) {\r\n      d = xd;\r\n      i = -i;\r\n      len = yd.length;\r\n    } else {\r\n      d = yd;\r\n      e = k;\r\n      len = xd.length;\r\n    }\r\n\r\n    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n    k = Math.ceil(pr / LOG_BASE);\r\n    len = k > len ? k + 1 : len + 1;\r\n\r\n    if (i > len) {\r\n      i = len;\r\n      d.length = 1;\r\n    }\r\n\r\n    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n    d.reverse();\r\n    for (; i--;) d.push(0);\r\n    d.reverse();\r\n  }\r\n\r\n  len = xd.length;\r\n  i = yd.length;\r\n\r\n  // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n  if (len - i < 0) {\r\n    i = len;\r\n    d = yd;\r\n    yd = xd;\r\n    xd = d;\r\n  }\r\n\r\n  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n  for (carry = 0; i;) {\r\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n    xd[i] %= BASE;\r\n  }\r\n\r\n  if (carry) {\r\n    xd.unshift(carry);\r\n    ++e;\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n  for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n  y.d = xd;\r\n  y.e = getBase10Exponent(xd, e);\r\n\r\n  return external ? finalise(y, pr, rm) : y;\r\n};\r\n\r\n\r\n/*\r\n * Return the number of significant digits of the value of this Decimal.\r\n *\r\n * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n *\r\n */\r\nP.precision = P.sd = function (z) {\r\n  var k,\r\n    x = this;\r\n\r\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n  if (x.d) {\r\n    k = getPrecision(x.d);\r\n    if (z && x.e + 1 > k) k = x.e + 1;\r\n  } else {\r\n    k = NaN;\r\n  }\r\n\r\n  return k;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n * rounding mode `rounding`.\r\n *\r\n */\r\nP.round = function () {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n *\r\n * sin(0)         = 0\r\n * sin(-0)        = -0\r\n * sin(Infinity)  = NaN\r\n * sin(-Infinity) = NaN\r\n * sin(NaN)       = NaN\r\n *\r\n */\r\nP.sine = P.sin = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n  Ctor.rounding = 1;\r\n\r\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n *  sqrt(-n) =  N\r\n *  sqrt(N)  =  N\r\n *  sqrt(-I) =  N\r\n *  sqrt(I)  =  I\r\n *  sqrt(0)  =  0\r\n *  sqrt(-0) = -0\r\n *\r\n */\r\nP.squareRoot = P.sqrt = function () {\r\n  var m, n, sd, r, rep, t,\r\n    x = this,\r\n    d = x.d,\r\n    e = x.e,\r\n    s = x.s,\r\n    Ctor = x.constructor;\r\n\r\n  // Negative/NaN/Infinity/zero?\r\n  if (s !== 1 || !d || !d[0]) {\r\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n  }\r\n\r\n  external = false;\r\n\r\n  // Initial estimate.\r\n  s = Math.sqrt(+x);\r\n\r\n  // Math.sqrt underflow/overflow?\r\n  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n  if (s == 0 || s == 1 / 0) {\r\n    n = digitsToString(d);\r\n\r\n    if ((n.length + e) % 2 == 0) n += '0';\r\n    s = Math.sqrt(n);\r\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n    if (s == 1 / 0) {\r\n      n = '1e' + e;\r\n    } else {\r\n      n = s.toExponential();\r\n      n = n.slice(0, n.indexOf('e') + 1) + e;\r\n    }\r\n\r\n    r = new Ctor(n);\r\n  } else {\r\n    r = new Ctor(s.toString());\r\n  }\r\n\r\n  sd = (e = Ctor.precision) + 3;\r\n\r\n  // Newton-Raphson iteration.\r\n  for (;;) {\r\n    t = r;\r\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n    // TODO? Replace with for-loop and checkRoundingDigits.\r\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n      n = n.slice(sd - 3, sd + 1);\r\n\r\n      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n      // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n      if (n == '9999' || !rep && n == '4999') {\r\n\r\n        // On the first iteration only, check to see if rounding up gives the exact result as the\r\n        // nines may infinitely repeat.\r\n        if (!rep) {\r\n          finalise(t, e + 1, 0);\r\n\r\n          if (t.times(t).eq(x)) {\r\n            r = t;\r\n            break;\r\n          }\r\n        }\r\n\r\n        sd += 4;\r\n        rep = 1;\r\n      } else {\r\n\r\n        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n        // If not, then there are further digits and m will be truthy.\r\n        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n          // Truncate to the first rounding digit.\r\n          finalise(r, e + 1, 1);\r\n          m = !r.times(r).eq(x);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, e, Ctor.rounding, m);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * tan(0)         = 0\r\n * tan(-0)        = -0\r\n * tan(Infinity)  = NaN\r\n * tan(-Infinity) = NaN\r\n * tan(NaN)       = NaN\r\n *\r\n */\r\nP.tangent = P.tan = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 10;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.sin();\r\n  x.s = 1;\r\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n *  n * 0 = 0\r\n *  n * N = N\r\n *  n * I = I\r\n *  0 * n = 0\r\n *  0 * 0 = 0\r\n *  0 * N = N\r\n *  0 * I = N\r\n *  N * n = N\r\n *  N * 0 = N\r\n *  N * N = N\r\n *  N * I = N\r\n *  I * n = I\r\n *  I * 0 = N\r\n *  I * N = N\r\n *  I * I = I\r\n *\r\n * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.times = P.mul = function (y) {\r\n  var carry, e, i, k, r, rL, t, xdL, ydL,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    xd = x.d,\r\n    yd = (y = new Ctor(y)).d;\r\n\r\n  y.s *= x.s;\r\n\r\n   // If either is NaN, Infinity or 0...\r\n  if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n      // Return NaN if either is NaN.\r\n      // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.\r\n      ? NaN\r\n\r\n      // Return Infinity if either is Infinity.\r\n      // Return 0 if either is 0.\r\n      : !xd || !yd ? y.s / 0 : y.s * 0);\r\n  }\r\n\r\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n  xdL = xd.length;\r\n  ydL = yd.length;\r\n\r\n  // Ensure xd points to the longer array.\r\n  if (xdL < ydL) {\r\n    r = xd;\r\n    xd = yd;\r\n    yd = r;\r\n    rL = xdL;\r\n    xdL = ydL;\r\n    ydL = rL;\r\n  }\r\n\r\n  // Initialise the result array with zeros.\r\n  r = [];\r\n  rL = xdL + ydL;\r\n  for (i = rL; i--;) r.push(0);\r\n\r\n  // Multiply!\r\n  for (i = ydL; --i >= 0;) {\r\n    carry = 0;\r\n    for (k = xdL + i; k > i;) {\r\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n      r[k--] = t % BASE | 0;\r\n      carry = t / BASE | 0;\r\n    }\r\n\r\n    r[k] = (r[k] + carry) % BASE | 0;\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  for (; !r[--rL];) r.pop();\r\n\r\n  if (carry) ++e;\r\n  else r.shift();\r\n\r\n  y.d = r;\r\n  y.e = getBase10Exponent(r, e);\r\n\r\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toBinary = function (sd, rm) {\r\n  return toStringBinary(this, 2, sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n *\r\n * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  x = new Ctor(x);\r\n  if (dp === void 0) return x;\r\n\r\n  checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n  if (rm === void 0) rm = Ctor.rounding;\r\n  else checkInt32(rm, 0, 8);\r\n\r\n  return finalise(x, dp + x.e + 1, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in exponential notation rounded to\r\n * `dp` fixed decimal places using rounding mode `rounding`.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toExponential = function (dp, rm) {\r\n  var str,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (dp === void 0) {\r\n    str = finiteToString(x, true);\r\n  } else {\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    x = finalise(new Ctor(x), dp + 1, rm);\r\n    str = finiteToString(x, true, dp + 1);\r\n  }\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n * omitted.\r\n *\r\n * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n * (-0).toFixed(3) is '0.000'.\r\n * (-0.5).toFixed(0) is '-0'.\r\n *\r\n */\r\nP.toFixed = function (dp, rm) {\r\n  var str, y,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (dp === void 0) {\r\n    str = finiteToString(x);\r\n  } else {\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n    str = finiteToString(y, false, dp + y.e + 1);\r\n  }\r\n\r\n  // To determine whether to add the minus sign look at the value before it was rounded,\r\n  // i.e. look at `x` rather than `y`.\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n * numerator and an integer denominator.\r\n *\r\n * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n * value necessary to represent the number exactly.\r\n *\r\n * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n *\r\n */\r\nP.toFraction = function (maxD) {\r\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n    x = this,\r\n    xd = x.d,\r\n    Ctor = x.constructor;\r\n\r\n  if (!xd) return new Ctor(x);\r\n\r\n  n1 = d0 = new Ctor(1);\r\n  d1 = n0 = new Ctor(0);\r\n\r\n  d = new Ctor(d1);\r\n  e = d.e = getPrecision(xd) - x.e - 1;\r\n  k = e % LOG_BASE;\r\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n  if (maxD == null) {\r\n\r\n    // d is 10**e, the minimum max-denominator needed.\r\n    maxD = e > 0 ? d : n1;\r\n  } else {\r\n    n = new Ctor(maxD);\r\n    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n    maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n  }\r\n\r\n  external = false;\r\n  n = new Ctor(digitsToString(xd));\r\n  pr = Ctor.precision;\r\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n  for (;;)  {\r\n    q = divide(n, d, 0, 1, 1);\r\n    d2 = d0.plus(q.times(d1));\r\n    if (d2.cmp(maxD) == 1) break;\r\n    d0 = d1;\r\n    d1 = d2;\r\n    d2 = n1;\r\n    n1 = n0.plus(q.times(d2));\r\n    n0 = d2;\r\n    d2 = d;\r\n    d = n.minus(q.times(d2));\r\n    n = d2;\r\n  }\r\n\r\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n  n0 = n0.plus(d2.times(n1));\r\n  d0 = d0.plus(d2.times(d1));\r\n  n0.s = n1.s = x.s;\r\n\r\n  // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n      ? [n1, d1] : [n0, d0];\r\n\r\n  Ctor.precision = pr;\r\n  external = true;\r\n\r\n  return r;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toHexadecimal = P.toHex = function (sd, rm) {\r\n  return toStringBinary(this, 16, sd, rm);\r\n};\r\n\r\n\r\n\r\n/*\r\n * Returns a new Decimal whose value is the nearest multiple of the magnitude of `y` to the value\r\n * of this Decimal.\r\n *\r\n * If the value of this Decimal is equidistant from two multiples of `y`, the rounding mode `rm`,\r\n * or `Decimal.rounding` if `rm` is omitted, determines the direction of the nearest multiple.\r\n *\r\n * In the context of this method, rounding mode 4 (ROUND_HALF_UP) is the same as rounding mode 0\r\n * (ROUND_UP), and so on.\r\n *\r\n * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n * or `y` is NaN, in which case the return value will be also be NaN.\r\n *\r\n * The return value is not affected by the value of `precision`.\r\n *\r\n * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toNearest() rounding mode not an integer: {rm}'\r\n * 'toNearest() rounding mode out of range: {rm}'\r\n *\r\n */\r\nP.toNearest = function (y, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  x = new Ctor(x);\r\n\r\n  if (y == null) {\r\n\r\n    // If x is not finite, return x.\r\n    if (!x.d) return x;\r\n\r\n    y = new Ctor(1);\r\n    rm = Ctor.rounding;\r\n  } else {\r\n    y = new Ctor(y);\r\n    if (rm !== void 0) checkInt32(rm, 0, 8);\r\n\r\n    // If x is not finite, return x if y is not NaN, else NaN.\r\n    if (!x.d) return y.s ? x : y;\r\n\r\n    // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n    if (!y.d) {\r\n      if (y.s) y.s = x.s;\r\n      return y;\r\n    }\r\n  }\r\n\r\n  // If y is not zero, calculate the nearest multiple of y to x.\r\n  if (y.d[0]) {\r\n    external = false;\r\n    if (rm < 4) rm = [4, 5, 7, 8][rm];\r\n    x = divide(x, y, 0, rm, 1).times(y);\r\n    external = true;\r\n    finalise(x);\r\n\r\n  // If y is zero, return zero with the sign of x.\r\n  } else {\r\n    y.s = x.s;\r\n    x = y;\r\n  }\r\n\r\n  return x;\r\n};\r\n\r\n\r\n/*\r\n * Return the value of this Decimal converted to a number primitive.\r\n * Zero keeps its sign.\r\n *\r\n */\r\nP.toNumber = function () {\r\n  return +this;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toOctal = function (sd, rm) {\r\n  return toStringBinary(this, 8, sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n * to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * ECMAScript compliant.\r\n *\r\n *   pow(x, NaN)                           = NaN\r\n *   pow(x, 0)                            = 1\r\n\r\n *   pow(NaN, non-zero)                    = NaN\r\n *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n *   pow(abs(x) > 1, -Infinity)            = +0\r\n *   pow(abs(x) == 1, Infinity)           = NaN\r\n *   pow(abs(x) < 1, +Infinity)            = +0\r\n *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n *   pow(+Infinity, y > 0)                 = +Infinity\r\n *   pow(+Infinity, y < 0)                 = +0\r\n *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n *   pow(-Infinity, even integer > 0)      = +Infinity\r\n *   pow(-Infinity, odd integer < 0)       = -0\r\n *   pow(-Infinity, even integer < 0)      = +0\r\n *   pow(+0, y > 0)                        = +0\r\n *   pow(+0, y < 0)                        = +Infinity\r\n *   pow(-0, odd integer > 0)              = -0\r\n *   pow(-0, even integer > 0)             = +0\r\n *   pow(-0, odd integer < 0)              = -Infinity\r\n *   pow(-0, even integer < 0)             = +Infinity\r\n *   pow(finite x < 0, finite non-integer) = NaN\r\n *\r\n * For non-integer or very large exponents pow(x, y) is calculated using\r\n *\r\n *   x^y = exp(y*ln(x))\r\n *\r\n * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n * probability of an incorrectly rounded result\r\n * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n * i.e. 1 in 250,000,000,000,000\r\n *\r\n * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n *\r\n * y {number|string|Decimal} The power to which to raise this Decimal.\r\n *\r\n */\r\nP.toPower = P.pow = function (y) {\r\n  var e, k, pr, r, rm, sign, yIsInt,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    yn = +(y = new Ctor(y));\r\n\r\n  // Either Infinity, NaN or 0?\r\n  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return  new Ctor(mathpow(+x, yn));\r\n\r\n  x = new Ctor(x);\r\n\r\n  if (x.eq(1)) return x;\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n  e = mathfloor(y.e / LOG_BASE);\r\n  k = y.d.length - 1;\r\n  yIsInt = e >= k;\r\n  sign = x.s;\r\n\r\n  if (!yIsInt) {\r\n    if (sign < 0) return new Ctor(NaN);\r\n\r\n  // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n  } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n    r = intPow(Ctor, x, k, pr);\r\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n  }\r\n\r\n  // Result is negative if x is negative and the last digit of integer y is odd.\r\n  sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;\r\n\r\n  // Estimate result exponent.\r\n  // x^y = 10^e,  where e = y * log10(x)\r\n  // log10(x) = log10(x_significand) + x_exponent\r\n  // log10(x_significand) = ln(x_significand) / ln(10)\r\n  k = mathpow(+x, yn);\r\n  e = k == 0 || !isFinite(k)\r\n    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n    : new Ctor(k + '').e;\r\n\r\n  // Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n  // Overflow/underflow?\r\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? sign / 0 : 0);\r\n\r\n  external = false;\r\n  Ctor.rounding = x.s = 1;\r\n\r\n  // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n  // new Decimal(2.32456).pow('2087987436534566.46411')\r\n  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n  k = Math.min(12, (e + '').length);\r\n\r\n  // r = x^y = exp(y*ln(x))\r\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n  // Truncate to the required precision plus five rounding digits.\r\n  r = finalise(r, pr + 5, 1);\r\n\r\n  // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n  // the result.\r\n  if (checkRoundingDigits(r.d, pr, rm)) {\r\n    e = pr + 10;\r\n\r\n    // Truncate to the increased precision plus five rounding digits.\r\n    r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n    // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n    if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n      r = finalise(r, pr + 1, 0);\r\n    }\r\n  }\r\n\r\n  r.s = sign;\r\n  external = true;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(r, pr, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toPrecision = function (sd, rm) {\r\n  var str,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (sd === void 0) {\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n  } else {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    x = finalise(new Ctor(x), sd, rm);\r\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n  }\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n * omitted.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toSD() digits out of range: {sd}'\r\n * 'toSD() digits not an integer: {sd}'\r\n * 'toSD() rounding mode not an integer: {rm}'\r\n * 'toSD() rounding mode out of range: {rm}'\r\n *\r\n */\r\nP.toSignificantDigits = P.toSD = function (sd, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (sd === void 0) {\r\n    sd = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n  } else {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n  }\r\n\r\n  return finalise(new Ctor(x), sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal.\r\n *\r\n * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n *\r\n */\r\nP.toString = function () {\r\n  var x = this,\r\n    Ctor = x.constructor,\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n *\r\n */\r\nP.truncated = P.trunc = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 1);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal.\r\n * Unlike `toString`, negative zero will include the minus sign.\r\n *\r\n */\r\nP.valueOf = P.toJSON = function () {\r\n  var x = this,\r\n    Ctor = x.constructor,\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n  return x.isNeg() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n// Add aliases to match BigDecimal method names.\r\n// P.add = P.plus;\r\nP.subtract = P.minus;\r\nP.multiply = P.times;\r\nP.divide = P.div;\r\nP.remainder = P.mod;\r\nP.compareTo = P.cmp;\r\nP.negate = P.neg;\r\n */\r\n\r\n\r\n// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n/*\r\n *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n *                           finiteToString, naturalExponential, naturalLogarithm\r\n *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n *  convertBase              toStringBinary, parseOther\r\n *  cos                      P.cos\r\n *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n *                           taylorSeries, atan2, parseOther\r\n *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n *                           naturalLogarithm, ceil, floor, round, trunc\r\n *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n *                           toStringBinary\r\n *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n *  getLn10                  P.logarithm, naturalLogarithm\r\n *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n *  getPrecision             P.precision, P.toFraction\r\n *  getZeroString            digitsToString, finiteToString\r\n *  intPow                   P.toPower, parseOther\r\n *  isOdd                    toLessThanHalfPi\r\n *  maxOrMin                 max, min\r\n *  naturalExponential       P.naturalExponential, P.toPower\r\n *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n *                           P.toPower, naturalExponential\r\n *  nonFiniteToString        finiteToString, toStringBinary\r\n *  parseDecimal             Decimal\r\n *  parseOther               Decimal\r\n *  sin                      P.sin\r\n *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n *  toLessThanHalfPi         P.cos, P.sin\r\n *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n *  truncate                 intPow\r\n *\r\n *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n *                           naturalLogarithm, config, parseOther, random, Decimal\r\n */\r\n\r\n\r\nfunction digitsToString(d) {\r\n  var i, k, ws,\r\n    indexOfLastWord = d.length - 1,\r\n    str = '',\r\n    w = d[0];\r\n\r\n  if (indexOfLastWord > 0) {\r\n    str += w;\r\n    for (i = 1; i < indexOfLastWord; i++) {\r\n      ws = d[i] + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n      str += ws;\r\n    }\r\n\r\n    w = d[i];\r\n    ws = w + '';\r\n    k = LOG_BASE - ws.length;\r\n    if (k) str += getZeroString(k);\r\n  } else if (w === 0) {\r\n    return '0';\r\n  }\r\n\r\n  // Remove trailing zeros of last w.\r\n  for (; w % 10 === 0;) w /= 10;\r\n\r\n  return str + w;\r\n}\r\n\r\n\r\nfunction checkInt32(i, min, max) {\r\n  if (i !== ~~i || i < min || i > max) {\r\n    throw Error(invalidArgument + i);\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n * `repeating == null` if caller is `log` or `pow`,\r\n * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n */\r\nfunction checkRoundingDigits(d, i, rm, repeating) {\r\n  var di, k, r, rd;\r\n\r\n  // Get the length of the first word of the array d.\r\n  for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n  // Is the rounding digit in the first word of d?\r\n  if (--i < 0) {\r\n    i += LOG_BASE;\r\n    di = 0;\r\n  } else {\r\n    di = Math.ceil((i + 1) / LOG_BASE);\r\n    i %= LOG_BASE;\r\n  }\r\n\r\n  // i is the index (0 - 6) of the rounding digit.\r\n  // E.g. if within the word 3487563 the first rounding digit is 5,\r\n  // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n  k = mathpow(10, LOG_BASE - i);\r\n  rd = d[di] % k | 0;\r\n\r\n  if (repeating == null) {\r\n    if (i < 3) {\r\n      if (i == 0) rd = rd / 100 | 0;\r\n      else if (i == 1) rd = rd / 10 | 0;\r\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n    } else {\r\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n        (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n          (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n    }\r\n  } else {\r\n    if (i < 4) {\r\n      if (i == 0) rd = rd / 1000 | 0;\r\n      else if (i == 1) rd = rd / 100 | 0;\r\n      else if (i == 2) rd = rd / 10 | 0;\r\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n    } else {\r\n      r = ((repeating || rm < 4) && rd + 1 == k ||\r\n      (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n        (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n    }\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n\r\n// Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n// Eg. convertBase('255', 10, 16) returns [15, 15].\r\n// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\nfunction convertBase(str, baseIn, baseOut) {\r\n  var j,\r\n    arr = [0],\r\n    arrL,\r\n    i = 0,\r\n    strL = str.length;\r\n\r\n  for (; i < strL;) {\r\n    for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n    for (j = 0; j < arr.length; j++) {\r\n      if (arr[j] > baseOut - 1) {\r\n        if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n        arr[j + 1] += arr[j] / baseOut | 0;\r\n        arr[j] %= baseOut;\r\n      }\r\n    }\r\n  }\r\n\r\n  return arr.reverse();\r\n}\r\n\r\n\r\n/*\r\n * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n * |x| < pi/2\r\n *\r\n */\r\nfunction cosine(Ctor, x) {\r\n  var k, y,\r\n    len = x.d.length;\r\n\r\n  // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n  // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  if (len < 32) {\r\n    k = Math.ceil(len / 3);\r\n    y = Math.pow(4, -k).toString();\r\n  } else {\r\n    k = 16;\r\n    y = '2.3283064365386962890625e-10';\r\n  }\r\n\r\n  Ctor.precision += k;\r\n\r\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n  // Reverse argument reduction\r\n  for (var i = k; i--;) {\r\n    var cos2x = x.times(x);\r\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n  }\r\n\r\n  Ctor.precision -= k;\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Perform division in the specified base.\r\n */\r\nvar divide = (function () {\r\n\r\n  // Assumes non-zero x and k, and hence non-zero result.\r\n  function multiplyInteger(x, k, base) {\r\n    var temp,\r\n      carry = 0,\r\n      i = x.length;\r\n\r\n    for (x = x.slice(); i--;) {\r\n      temp = x[i] * k + carry;\r\n      x[i] = temp % base | 0;\r\n      carry = temp / base | 0;\r\n    }\r\n\r\n    if (carry) x.unshift(carry);\r\n\r\n    return x;\r\n  }\r\n\r\n  function compare(a, b, aL, bL) {\r\n    var i, r;\r\n\r\n    if (aL != bL) {\r\n      r = aL > bL ? 1 : -1;\r\n    } else {\r\n      for (i = r = 0; i < aL; i++) {\r\n        if (a[i] != b[i]) {\r\n          r = a[i] > b[i] ? 1 : -1;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n  function subtract(a, b, aL, base) {\r\n    var i = 0;\r\n\r\n    // Subtract b from a.\r\n    for (; aL--;) {\r\n      a[aL] -= i;\r\n      i = a[aL] < b[aL] ? 1 : 0;\r\n      a[aL] = i * base + a[aL] - b[aL];\r\n    }\r\n\r\n    // Remove leading zeros.\r\n    for (; !a[0] && a.length > 1;) a.shift();\r\n  }\r\n\r\n  return function (x, y, pr, rm, dp, base) {\r\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n      yL, yz,\r\n      Ctor = x.constructor,\r\n      sign = x.s == y.s ? 1 : -1,\r\n      xd = x.d,\r\n      yd = y.d;\r\n\r\n    // Either NaN, Infinity or 0?\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n        // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n        xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n    }\r\n\r\n    if (base) {\r\n      logBase = 1;\r\n      e = x.e - y.e;\r\n    } else {\r\n      base = BASE;\r\n      logBase = LOG_BASE;\r\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n    }\r\n\r\n    yL = yd.length;\r\n    xL = xd.length;\r\n    q = new Ctor(sign);\r\n    qd = q.d = [];\r\n\r\n    // Result exponent may be one less than e.\r\n    // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n    for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n    if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n    if (pr == null) {\r\n      sd = pr = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else if (dp) {\r\n      sd = pr + (x.e - y.e) + 1;\r\n    } else {\r\n      sd = pr;\r\n    }\r\n\r\n    if (sd < 0) {\r\n      qd.push(1);\r\n      more = true;\r\n    } else {\r\n\r\n      // Convert precision in number of base 10 digits to base 1e7 digits.\r\n      sd = sd / logBase + 2 | 0;\r\n      i = 0;\r\n\r\n      // divisor < 1e7\r\n      if (yL == 1) {\r\n        k = 0;\r\n        yd = yd[0];\r\n        sd++;\r\n\r\n        // k is the carry.\r\n        for (; (i < xL || k) && sd--; i++) {\r\n          t = k * base + (xd[i] || 0);\r\n          qd[i] = t / yd | 0;\r\n          k = t % yd | 0;\r\n        }\r\n\r\n        more = k || i < xL;\r\n\r\n      // divisor >= 1e7\r\n      } else {\r\n\r\n        // Normalise xd and yd so highest order digit of yd is >= base/2\r\n        k = base / (yd[0] + 1) | 0;\r\n\r\n        if (k > 1) {\r\n          yd = multiplyInteger(yd, k, base);\r\n          xd = multiplyInteger(xd, k, base);\r\n          yL = yd.length;\r\n          xL = xd.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xd.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL;) rem[remL++] = 0;\r\n\r\n        yz = yd.slice();\r\n        yz.unshift(0);\r\n        yd0 = yd[0];\r\n\r\n        if (yd[1] >= base / 2) ++yd0;\r\n\r\n        do {\r\n          k = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yd, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, k.\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // k will be how many times the divisor goes into the current remainder.\r\n            k = rem0 / yd0 | 0;\r\n\r\n            //  Algorithm:\r\n            //  1. product = divisor * trial digit (k)\r\n            //  2. if product > remainder: product -= divisor, k--\r\n            //  3. remainder -= product\r\n            //  4. if product was < remainder at 2:\r\n            //    5. compare new remainder and divisor\r\n            //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n            if (k > 1) {\r\n              if (k >= base) k = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiplyInteger(yd, k, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              cmp = compare(prod, rem, prodL, remL);\r\n\r\n              // product > remainder.\r\n              if (cmp == 1) {\r\n                k--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n              }\r\n            } else {\r\n\r\n              // cmp is -1.\r\n              // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n              // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n              if (k == 0) cmp = k = 1;\r\n              prod = yd.slice();\r\n            }\r\n\r\n            prodL = prod.length;\r\n            if (prodL < remL) prod.unshift(0);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n\r\n            // If product was < previous remainder.\r\n            if (cmp == -1) {\r\n              remL = rem.length;\r\n\r\n              // Compare divisor and new remainder.\r\n              cmp = compare(yd, rem, yL, remL);\r\n\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              if (cmp < 1) {\r\n                k++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yd, remL, base);\r\n              }\r\n            }\r\n\r\n            remL = rem.length;\r\n          } else if (cmp === 0) {\r\n            k++;\r\n            rem = [0];\r\n          }    // if cmp === 1, k will be 0\r\n\r\n          // Add the next digit, k, to the result array.\r\n          qd[i++] = k;\r\n\r\n          // Update the remainder.\r\n          if (cmp && rem[0]) {\r\n            rem[remL++] = xd[xi] || 0;\r\n          } else {\r\n            rem = [xd[xi]];\r\n            remL = 1;\r\n          }\r\n\r\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n        more = rem[0] !== void 0;\r\n      }\r\n\r\n      // Leading zero?\r\n      if (!qd[0]) qd.shift();\r\n    }\r\n\r\n    // logBase is 1 when divide is being used for base conversion.\r\n    if (logBase == 1) {\r\n      q.e = e;\r\n      inexact = more;\r\n    } else {\r\n\r\n      // To calculate q.e, first get the number of digits of qd[0].\r\n      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n      q.e = i + e * logBase - 1;\r\n\r\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n    }\r\n\r\n    return q;\r\n  };\r\n})();\r\n\r\n\r\n/*\r\n * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n * Check for over/under-flow.\r\n */\r\n function finalise(x, sd, rm, isTruncated) {\r\n  var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n    Ctor = x.constructor;\r\n\r\n  // Don't round if sd is null or undefined.\r\n  out: if (sd != null) {\r\n    xd = x.d;\r\n\r\n    // Infinity/NaN.\r\n    if (!xd) return x;\r\n\r\n    // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n    // w: the word of xd containing rd, a base 1e7 number.\r\n    // xdi: the index of w within xd.\r\n    // digits: the number of digits of w.\r\n    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n    // they had leading zeros)\r\n    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n    // Get the length of the first word of the digits array xd.\r\n    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n    i = sd - digits;\r\n\r\n    // Is the rounding digit in the first word of xd?\r\n    if (i < 0) {\r\n      i += LOG_BASE;\r\n      j = sd;\r\n      w = xd[xdi = 0];\r\n\r\n      // Get the rounding digit at index j of w.\r\n      rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n    } else {\r\n      xdi = Math.ceil((i + 1) / LOG_BASE);\r\n      k = xd.length;\r\n      if (xdi >= k) {\r\n        if (isTruncated) {\r\n\r\n          // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n          for (; k++ <= xdi;) xd.push(0);\r\n          w = rd = 0;\r\n          digits = 1;\r\n          i %= LOG_BASE;\r\n          j = i - LOG_BASE + 1;\r\n        } else {\r\n          break out;\r\n        }\r\n      } else {\r\n        w = k = xd[xdi];\r\n\r\n        // Get the number of digits of w.\r\n        for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n        // Get the index of rd within w.\r\n        i %= LOG_BASE;\r\n\r\n        // Get the index of rd within w, adjusted for leading zeros.\r\n        // The number of leading zeros of w is given by LOG_BASE - digits.\r\n        j = i - LOG_BASE + digits;\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      }\r\n    }\r\n\r\n    // Are there any non-zero digits after the rounding digit?\r\n    isTruncated = isTruncated || sd < 0 ||\r\n      xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n    // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n    // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n    // will give 714.\r\n\r\n    roundUp = rm < 4\r\n      ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n      : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n        // Check whether the digit to the left of the rounding digit is odd.\r\n        ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n          rm == (x.s < 0 ? 8 : 7));\r\n\r\n    if (sd < 1 || !xd[0]) {\r\n      xd.length = 0;\r\n      if (roundUp) {\r\n\r\n        // Convert sd to decimal places.\r\n        sd -= x.e + 1;\r\n\r\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n        x.e = -sd || 0;\r\n      } else {\r\n\r\n        // Zero.\r\n        xd[0] = x.e = 0;\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n    // Remove excess digits.\r\n    if (i == 0) {\r\n      xd.length = xdi;\r\n      k = 1;\r\n      xdi--;\r\n    } else {\r\n      xd.length = xdi + 1;\r\n      k = mathpow(10, LOG_BASE - i);\r\n\r\n      // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n      // j > 0 means i > number of leading zeros of w.\r\n      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n    }\r\n\r\n    if (roundUp) {\r\n      for (;;) {\r\n\r\n        // Is the digit to be rounded up in the first word of xd?\r\n        if (xdi == 0) {\r\n\r\n          // i will be the length of xd[0] before k is added.\r\n          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n          j = xd[0] += k;\r\n          for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n          // if i != k the length has increased.\r\n          if (i != k) {\r\n            x.e++;\r\n            if (xd[0] == BASE) xd[0] = 1;\r\n          }\r\n\r\n          break;\r\n        } else {\r\n          xd[xdi] += k;\r\n          if (xd[xdi] != BASE) break;\r\n          xd[xdi--] = 0;\r\n          k = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n  }\r\n\r\n  if (external) {\r\n\r\n    // Overflow?\r\n    if (x.e > Ctor.maxE) {\r\n\r\n      // Infinity.\r\n      x.d = null;\r\n      x.e = NaN;\r\n\r\n    // Underflow?\r\n    } else if (x.e < Ctor.minE) {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n      // Ctor.underflow = true;\r\n    } // else Ctor.underflow = false;\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\nfunction finiteToString(x, isExp, sd) {\r\n  if (!x.isFinite()) return nonFiniteToString(x);\r\n  var k,\r\n    e = x.e,\r\n    str = digitsToString(x.d),\r\n    len = str.length;\r\n\r\n  if (isExp) {\r\n    if (sd && (k = sd - len) > 0) {\r\n      str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n    } else if (len > 1) {\r\n      str = str.charAt(0) + '.' + str.slice(1);\r\n    }\r\n\r\n    str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n  } else if (e < 0) {\r\n    str = '0.' + getZeroString(-e - 1) + str;\r\n    if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n  } else if (e >= len) {\r\n    str += getZeroString(e + 1 - len);\r\n    if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n  } else {\r\n    if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n    if (sd && (k = sd - len) > 0) {\r\n      if (e + 1 === len) str += '.';\r\n      str += getZeroString(k);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// Calculate the base 10 exponent from the base 1e7 exponent.\r\nfunction getBase10Exponent(digits, e) {\r\n  var w = digits[0];\r\n\r\n  // Add the number of digits of the first word of the digits array.\r\n  for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n  return e;\r\n}\r\n\r\n\r\nfunction getLn10(Ctor, sd, pr) {\r\n  if (sd > LN10_PRECISION) {\r\n\r\n    // Reset global state in case the exception is caught.\r\n    external = true;\r\n    if (pr) Ctor.precision = pr;\r\n    throw Error(precisionLimitExceeded);\r\n  }\r\n  return finalise(new Ctor(LN10), sd, 1, true);\r\n}\r\n\r\n\r\nfunction getPi(Ctor, sd, rm) {\r\n  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n  return finalise(new Ctor(PI), sd, rm, true);\r\n}\r\n\r\n\r\nfunction getPrecision(digits) {\r\n  var w = digits.length - 1,\r\n    len = w * LOG_BASE + 1;\r\n\r\n  w = digits[w];\r\n\r\n  // If non-zero...\r\n  if (w) {\r\n\r\n    // Subtract the number of trailing zeros of the last word.\r\n    for (; w % 10 == 0; w /= 10) len--;\r\n\r\n    // Add the number of digits of the first word.\r\n    for (w = digits[0]; w >= 10; w /= 10) len++;\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n\r\nfunction getZeroString(k) {\r\n  var zs = '';\r\n  for (; k--;) zs += '0';\r\n  return zs;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n * integer of type number.\r\n *\r\n * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n *\r\n */\r\nfunction intPow(Ctor, x, n, pr) {\r\n  var isTruncated,\r\n    r = new Ctor(1),\r\n\r\n    // Max n of 9007199254740991 takes 53 loop iterations.\r\n    // Maximum digits array length; leaves [28, 34] guard digits.\r\n    k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n  external = false;\r\n\r\n  for (;;) {\r\n    if (n % 2) {\r\n      r = r.times(x);\r\n      if (truncate(r.d, k)) isTruncated = true;\r\n    }\r\n\r\n    n = mathfloor(n / 2);\r\n    if (n === 0) {\r\n\r\n      // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n      n = r.d.length - 1;\r\n      if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n      break;\r\n    }\r\n\r\n    x = x.times(x);\r\n    truncate(x.d, k);\r\n  }\r\n\r\n  external = true;\r\n\r\n  return r;\r\n}\r\n\r\n\r\nfunction isOdd(n) {\r\n  return n.d[n.d.length - 1] & 1;\r\n}\r\n\r\n\r\n/*\r\n * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n */\r\nfunction maxOrMin(Ctor, args, ltgt) {\r\n  var y,\r\n    x = new Ctor(args[0]),\r\n    i = 0;\r\n\r\n  for (; ++i < args.length;) {\r\n    y = new Ctor(args[i]);\r\n    if (!y.s) {\r\n      x = y;\r\n      break;\r\n    } else if (x[ltgt](y)) {\r\n      x = y;\r\n    }\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n * Taylor/Maclaurin series.\r\n *\r\n * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n *\r\n * Argument reduction:\r\n *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n *   exp(x) = exp(x / 2^k)^(2^k)\r\n *\r\n * Previously, the argument was initially reduced by\r\n * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n * found to be slower than just dividing repeatedly by 32 as above.\r\n *\r\n * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n *\r\n *  exp(Infinity)  = Infinity\r\n *  exp(-Infinity) = 0\r\n *  exp(NaN)       = NaN\r\n *  exp(0)        = 1\r\n *\r\n *  exp(x) is non-terminating for any finite, non-zero x.\r\n *\r\n *  The result will always be correctly rounded.\r\n *\r\n */\r\nfunction naturalExponential(x, sd) {\r\n  var denominator, guard, j, pow, sum, t, wpr,\r\n    rep = 0,\r\n    i = 0,\r\n    k = 0,\r\n    Ctor = x.constructor,\r\n    rm = Ctor.rounding,\r\n    pr = Ctor.precision;\r\n\r\n  // 0/NaN/Infinity?\r\n  if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n    return new Ctor(x.d\r\n      ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n      : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n  }\r\n\r\n  if (sd == null) {\r\n    external = false;\r\n    wpr = pr;\r\n  } else {\r\n    wpr = sd;\r\n  }\r\n\r\n  t = new Ctor(0.03125);\r\n\r\n  // while abs(x) >= 0.1\r\n  while (x.e > -2) {\r\n\r\n    // x = x / 2^5\r\n    x = x.times(t);\r\n    k += 5;\r\n  }\r\n\r\n  // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n  // necessary to ensure the first 4 rounding digits are correct.\r\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n  wpr += guard;\r\n  denominator = pow = sum = new Ctor(1);\r\n  Ctor.precision = wpr;\r\n\r\n  for (;;) {\r\n    pow = finalise(pow.times(x), wpr, 1);\r\n    denominator = denominator.times(++i);\r\n    t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n      j = k;\r\n      while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n      // Check to see if the first 4 rounding digits are [49]999.\r\n      // If so, repeat the summation with a higher precision, otherwise\r\n      // e.g. with precision: 18, rounding: 1\r\n      // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n      // `wpr - guard` is the index of first rounding digit.\r\n      if (sd == null) {\r\n\r\n        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n          Ctor.precision = wpr += 10;\r\n          denominator = pow = t = new Ctor(1);\r\n          i = 0;\r\n          rep++;\r\n        } else {\r\n          return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n        }\r\n      } else {\r\n        Ctor.precision = pr;\r\n        return sum;\r\n      }\r\n    }\r\n\r\n    sum = t;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n *  ln(-n)        = NaN\r\n *  ln(0)         = -Infinity\r\n *  ln(-0)        = -Infinity\r\n *  ln(1)         = 0\r\n *  ln(Infinity)  = Infinity\r\n *  ln(-Infinity) = NaN\r\n *  ln(NaN)       = NaN\r\n *\r\n *  ln(n) (n != 1) is non-terminating.\r\n *\r\n */\r\nfunction naturalLogarithm(y, sd) {\r\n  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n    n = 1,\r\n    guard = 10,\r\n    x = y,\r\n    xd = x.d,\r\n    Ctor = x.constructor,\r\n    rm = Ctor.rounding,\r\n    pr = Ctor.precision;\r\n\r\n  // Is x negative or Infinity, NaN, 0 or 1?\r\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n  }\r\n\r\n  if (sd == null) {\r\n    external = false;\r\n    wpr = pr;\r\n  } else {\r\n    wpr = sd;\r\n  }\r\n\r\n  Ctor.precision = wpr += guard;\r\n  c = digitsToString(xd);\r\n  c0 = c.charAt(0);\r\n\r\n  if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n    // Argument reduction.\r\n    // The series converges faster the closer the argument is to 1, so using\r\n    // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n    // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n    // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n    // later be divided by this number, then separate out the power of 10 using\r\n    // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n    // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n    //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n    // max n is 6 (gives 0.7 - 1.3)\r\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n      x = x.times(y);\r\n      c = digitsToString(x.d);\r\n      c0 = c.charAt(0);\r\n      n++;\r\n    }\r\n\r\n    e = x.e;\r\n\r\n    if (c0 > 1) {\r\n      x = new Ctor('0.' + c);\r\n      e++;\r\n    } else {\r\n      x = new Ctor(c0 + '.' + c.slice(1));\r\n    }\r\n  } else {\r\n\r\n    // The argument reduction method above may result in overflow if the argument y is a massive\r\n    // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n    // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n    t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n    x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n    Ctor.precision = pr;\r\n\r\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n  }\r\n\r\n  // x1 is x reduced to a value near 1.\r\n  x1 = x;\r\n\r\n  // Taylor series.\r\n  // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n  // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n  x2 = finalise(x.times(x), wpr, 1);\r\n  denominator = 3;\r\n\r\n  for (;;) {\r\n    numerator = finalise(numerator.times(x2), wpr, 1);\r\n    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n      sum = sum.times(2);\r\n\r\n      // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n      // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n      if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n      sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n      // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n      // been repeated previously) and the first 4 rounding digits 9999?\r\n      // If so, restart the summation with a higher precision, otherwise\r\n      // e.g. with precision: 12, rounding: 1\r\n      // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n      // `wpr - guard` is the index of first rounding digit.\r\n      if (sd == null) {\r\n        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n          Ctor.precision = wpr += guard;\r\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n          x2 = finalise(x.times(x), wpr, 1);\r\n          denominator = rep = 1;\r\n        } else {\r\n          return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n        }\r\n      } else {\r\n        Ctor.precision = pr;\r\n        return sum;\r\n      }\r\n    }\r\n\r\n    sum = t;\r\n    denominator += 2;\r\n  }\r\n}\r\n\r\n\r\n// Infinity, NaN.\r\nfunction nonFiniteToString(x) {\r\n  // Unsigned.\r\n  return String(x.s * x.s / 0);\r\n}\r\n\r\n\r\n/*\r\n * Parse the value of a new Decimal `x` from string `str`.\r\n */\r\nfunction parseDecimal(x, str) {\r\n  var e, i, len;\r\n\r\n  // Decimal point?\r\n  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n  // Exponential form?\r\n  if ((i = str.search(/e/i)) > 0) {\r\n\r\n    // Determine exponent.\r\n    if (e < 0) e = i;\r\n    e += +str.slice(i + 1);\r\n    str = str.substring(0, i);\r\n  } else if (e < 0) {\r\n\r\n    // Integer.\r\n    e = str.length;\r\n  }\r\n\r\n  // Determine leading zeros.\r\n  for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n  // Determine trailing zeros.\r\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n  str = str.slice(i, len);\r\n\r\n  if (str) {\r\n    len -= i;\r\n    x.e = e = e - i - 1;\r\n    x.d = [];\r\n\r\n    // Transform base\r\n\r\n    // e is the base 10 exponent.\r\n    // i is where to slice str to get the first word of the digits array.\r\n    i = (e + 1) % LOG_BASE;\r\n    if (e < 0) i += LOG_BASE;\r\n\r\n    if (i < len) {\r\n      if (i) x.d.push(+str.slice(0, i));\r\n      for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n      str = str.slice(i);\r\n      i = LOG_BASE - str.length;\r\n    } else {\r\n      i -= len;\r\n    }\r\n\r\n    for (; i--;) str += '0';\r\n    x.d.push(+str);\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > x.constructor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < x.constructor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // x.constructor.underflow = true;\r\n      } // else x.constructor.underflow = false;\r\n    }\r\n  } else {\r\n\r\n    // Zero.\r\n    x.e = 0;\r\n    x.d = [0];\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n */\r\nfunction parseOther(x, str) {\r\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n  if (str === 'Infinity' || str === 'NaN') {\r\n    if (!+str) x.s = NaN;\r\n    x.e = NaN;\r\n    x.d = null;\r\n    return x;\r\n  }\r\n\r\n  if (isHex.test(str))  {\r\n    base = 16;\r\n    str = str.toLowerCase();\r\n  } else if (isBinary.test(str))  {\r\n    base = 2;\r\n  } else if (isOctal.test(str))  {\r\n    base = 8;\r\n  } else {\r\n    throw Error(invalidArgument + str);\r\n  }\r\n\r\n  // Is there a binary exponent part?\r\n  i = str.search(/p/i);\r\n\r\n  if (i > 0) {\r\n    p = +str.slice(i + 1);\r\n    str = str.substring(2, i);\r\n  } else {\r\n    str = str.slice(2);\r\n  }\r\n\r\n  // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n  // fraction part will be restored.\r\n  i = str.indexOf('.');\r\n  isFloat = i >= 0;\r\n  Ctor = x.constructor;\r\n\r\n  if (isFloat) {\r\n    str = str.replace('.', '');\r\n    len = str.length;\r\n    i = len - i;\r\n\r\n    // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n  }\r\n\r\n  xd = convertBase(str, base, BASE);\r\n  xe = xd.length - 1;\r\n\r\n  // Remove trailing zeros.\r\n  for (i = xe; xd[i] === 0; --i) xd.pop();\r\n  if (i < 0) return new Ctor(x.s * 0);\r\n  x.e = getBase10Exponent(xd, xe);\r\n  x.d = xd;\r\n  external = false;\r\n\r\n  // At what precision to perform the division to ensure exact conversion?\r\n  // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n  // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n  // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n  // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n  // Therefore using 4 * the number of digits of str will always be enough.\r\n  if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n  // Multiply by the binary exponent part if present.\r\n  if (p) x = x.times(Math.abs(p) < 54 ? Math.pow(2, p) : Decimal.pow(2, p));\r\n  external = true;\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n * |x| < pi/2\r\n *\r\n */\r\nfunction sine(Ctor, x) {\r\n  var k,\r\n    len = x.d.length;\r\n\r\n  if (len < 3) return taylorSeries(Ctor, 2, x, x);\r\n\r\n  // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n  // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n  // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  k = 1.4 * Math.sqrt(len);\r\n  k = k > 16 ? 16 : k | 0;\r\n\r\n  // Max k before Math.pow precision loss is 22\r\n  x = x.times(Math.pow(5, -k));\r\n  x = taylorSeries(Ctor, 2, x, x);\r\n\r\n  // Reverse argument reduction\r\n  var sin2_x,\r\n    d5 = new Ctor(5),\r\n    d16 = new Ctor(16),\r\n    d20 = new Ctor(20);\r\n  for (; k--;) {\r\n    sin2_x = x.times(x);\r\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n  var j, t, u, x2,\r\n    i = 1,\r\n    pr = Ctor.precision,\r\n    k = Math.ceil(pr / LOG_BASE);\r\n\r\n  external = false;\r\n  x2 = x.times(x);\r\n  u = new Ctor(y);\r\n\r\n  for (;;) {\r\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n    t = u.plus(y);\r\n\r\n    if (t.d[k] !== void 0) {\r\n      for (j = k; t.d[j] === u.d[j] && j--;);\r\n      if (j == -1) break;\r\n    }\r\n\r\n    j = u;\r\n    u = y;\r\n    y = t;\r\n    t = j;\r\n    i++;\r\n  }\r\n\r\n  external = true;\r\n  t.d.length = k + 1;\r\n\r\n  return t;\r\n}\r\n\r\n\r\n// Return the absolute value of `x` reduced to less than or equal to half pi.\r\nfunction toLessThanHalfPi(Ctor, x) {\r\n  var t,\r\n    isNeg = x.s < 0,\r\n    pi = getPi(Ctor, Ctor.precision, 1),\r\n    halfPi = pi.times(0.5);\r\n\r\n  x = x.abs();\r\n\r\n  if (x.lte(halfPi)) {\r\n    quadrant = isNeg ? 4 : 1;\r\n    return x;\r\n  }\r\n\r\n  t = x.divToInt(pi);\r\n\r\n  if (t.isZero()) {\r\n    quadrant = isNeg ? 3 : 2;\r\n  } else {\r\n    x = x.minus(t.times(pi));\r\n\r\n    // 0 <= x < pi\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n      return x;\r\n    }\r\n\r\n    quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n  }\r\n\r\n  return x.minus(pi).abs();\r\n}\r\n\r\n\r\n/*\r\n * Return the value of Decimal `x` as a string in base `baseOut`.\r\n *\r\n * If the optional `sd` argument is present include a binary exponent suffix.\r\n */\r\nfunction toStringBinary(x, baseOut, sd, rm) {\r\n  var base, e, i, k, len, roundUp, str, xd, y,\r\n    Ctor = x.constructor,\r\n    isExp = sd !== void 0;\r\n\r\n  if (isExp) {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n  } else {\r\n    sd = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n  }\r\n\r\n  if (!x.isFinite()) {\r\n    str = nonFiniteToString(x);\r\n  } else {\r\n    str = finiteToString(x);\r\n    i = str.indexOf('.');\r\n\r\n    // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n    // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n    // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n    // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n    if (isExp) {\r\n      base = 2;\r\n      if (baseOut == 16) {\r\n        sd = sd * 4 - 3;\r\n      } else if (baseOut == 8) {\r\n        sd = sd * 3 - 2;\r\n      }\r\n    } else {\r\n      base = baseOut;\r\n    }\r\n\r\n    // Convert the number as an integer then divide the result by its base raised to a power such\r\n    // that the fraction part will be restored.\r\n\r\n    // Non-integer.\r\n    if (i >= 0) {\r\n      str = str.replace('.', '');\r\n      y = new Ctor(1);\r\n      y.e = str.length - i;\r\n      y.d = convertBase(finiteToString(y), 10, base);\r\n      y.e = y.d.length;\r\n    }\r\n\r\n    xd = convertBase(str, 10, base);\r\n    e = len = xd.length;\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] == 0;) xd.pop();\r\n\r\n    if (!xd[0]) {\r\n      str = isExp ? '0p+0' : '0';\r\n    } else {\r\n      if (i < 0) {\r\n        e--;\r\n      } else {\r\n        x = new Ctor(x);\r\n        x.d = xd;\r\n        x.e = e;\r\n        x = divide(x, y, sd, rm, 0, base);\r\n        xd = x.d;\r\n        e = x.e;\r\n        roundUp = inexact;\r\n      }\r\n\r\n      // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      i = xd[sd];\r\n      k = base / 2;\r\n      roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n      roundUp = rm < 4\r\n        ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n        : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n          rm === (x.s < 0 ? 8 : 7));\r\n\r\n      xd.length = sd;\r\n\r\n      if (roundUp) {\r\n\r\n        // Rounding up may mean the previous digit has to be rounded up and so on.\r\n        for (; ++xd[--sd] > base - 1;) {\r\n          xd[sd] = 0;\r\n          if (!sd) {\r\n            ++e;\r\n            xd.unshift(1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Determine trailing zeros.\r\n      for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n      // E.g. [4, 11, 15] becomes 4bf.\r\n      for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n      // Add binary exponent suffix?\r\n      if (isExp) {\r\n        if (len > 1) {\r\n          if (baseOut == 16 || baseOut == 8) {\r\n            i = baseOut == 16 ? 4 : 3;\r\n            for (--len; len % i; len++) str += '0';\r\n            xd = convertBase(str, base, baseOut);\r\n            for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n            // xd[0] will always be be 1\r\n            for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n          } else {\r\n            str = str.charAt(0) + '.' + str.slice(1);\r\n          }\r\n        }\r\n\r\n        str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n      } else if (e < 0) {\r\n        for (; ++e;) str = '0' + str;\r\n        str = '0.' + str;\r\n      } else {\r\n        if (++e > len) for (e -= len; e-- ;) str += '0';\r\n        else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n  }\r\n\r\n  return x.s < 0 ? '-' + str : str;\r\n}\r\n\r\n\r\n// Does not strip trailing zeros.\r\nfunction truncate(arr, len) {\r\n  if (arr.length > len) {\r\n    arr.length = len;\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n// Decimal methods\r\n\r\n\r\n/*\r\n *  abs\r\n *  acos\r\n *  acosh\r\n *  add\r\n *  asin\r\n *  asinh\r\n *  atan\r\n *  atanh\r\n *  atan2\r\n *  cbrt\r\n *  ceil\r\n *  clone\r\n *  config\r\n *  cos\r\n *  cosh\r\n *  div\r\n *  exp\r\n *  floor\r\n *  hypot\r\n *  ln\r\n *  log\r\n *  log2\r\n *  log10\r\n *  max\r\n *  min\r\n *  mod\r\n *  mul\r\n *  pow\r\n *  random\r\n *  round\r\n *  set\r\n *  sign\r\n *  sin\r\n *  sinh\r\n *  sqrt\r\n *  sub\r\n *  tan\r\n *  tanh\r\n *  trunc\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the absolute value of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction abs(x) {\r\n  return new this(x).abs();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction acos(x) {\r\n  return new this(x).acos();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction acosh(x) {\r\n  return new this(x).acosh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction add(x, y) {\r\n  return new this(x).plus(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction asin(x) {\r\n  return new this(x).asin();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction asinh(x) {\r\n  return new this(x).asinh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction atan(x) {\r\n  return new this(x).atan();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction atanh(x) {\r\n  return new this(x).atanh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi, pi]\r\n *\r\n * y {number|string|Decimal} The y-coordinate.\r\n * x {number|string|Decimal} The x-coordinate.\r\n *\r\n * atan2(0, -0)               = pi\r\n * atan2(0, +0)               = 0\r\n * atan2(0, -x)               = pi for x > 0\r\n * atan2(0, x)                = 0 for x > 0\r\n * atan2(-y, 0)               = -pi/2 for y > 0\r\n * atan2(y, 0)                = pi/2 for y > 0\r\n * atan2(y, -Infinity)        = pi for finite y > 0\r\n * atan2(y, +Infinity)        = 0 for finite y > 0\r\n * atan2(Infinity, x)         = pi/2 for finite x\r\n * atan2(Infinity, -Infinity) = 3*pi/4\r\n * atan2(Infinity, +Infinity) = pi/4\r\n * atan2(NaN, x) = NaN\r\n * atan2(y, NaN) = NaN\r\n *\r\n */\r\nfunction atan2(y, x) {\r\n  y = new this(y);\r\n  x = new this(x);\r\n  var r,\r\n    pr = this.precision,\r\n    rm = this.rounding,\r\n    wpr = pr + 4;\r\n\r\n  // Either NaN\r\n  if (!y.s || !x.s) {\r\n    r = new this(NaN);\r\n\r\n  // Both Infinity\r\n  } else if (!y.d && !x.d) {\r\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n    r.s = y.s;\r\n\r\n  // x is Infinity or y is 0\r\n  } else if (!x.d || y.isZero()) {\r\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n    r.s = y.s;\r\n\r\n  // y is Infinity or x is 0\r\n  } else if (!y.d || x.isZero()) {\r\n    r = getPi(this, wpr, 1).times(0.5);\r\n    r.s = y.s;\r\n\r\n  // Both non-zero and finite\r\n  } else if (x.s < 0) {\r\n    this.precision = wpr;\r\n    this.rounding = 1;\r\n    r = this.atan(divide(y, x, wpr, 1));\r\n    x = getPi(this, wpr, 1);\r\n    this.precision = pr;\r\n    this.rounding = rm;\r\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n  } else {\r\n    r = this.atan(divide(y, x, wpr, 1));\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction cbrt(x) {\r\n  return new this(x).cbrt();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction ceil(x) {\r\n  return finalise(x = new this(x), x.e + 1, 2);\r\n}\r\n\r\n\r\n/*\r\n * Configure global settings for a Decimal constructor.\r\n *\r\n * `obj` is an object with one or more of the following properties,\r\n *\r\n *   precision  {number}\r\n *   rounding   {number}\r\n *   toExpNeg   {number}\r\n *   toExpPos   {number}\r\n *   maxE       {number}\r\n *   minE       {number}\r\n *   modulo     {number}\r\n *   crypto     {boolean|number}\r\n *\r\n * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n *\r\n */\r\nfunction config(obj) {\r\n  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n  var i, p, v,\r\n    ps = [\r\n      'precision', 1, MAX_DIGITS,\r\n      'rounding', 0, 8,\r\n      'toExpNeg', -EXP_LIMIT, 0,\r\n      'toExpPos', 0, EXP_LIMIT,\r\n      'maxE', 0, EXP_LIMIT,\r\n      'minE', -EXP_LIMIT, 0,\r\n      'modulo', 0, 9\r\n    ];\r\n\r\n  for (i = 0; i < ps.length; i += 3) {\r\n    if ((v = obj[p = ps[i]]) !== void 0) {\r\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n      else throw Error(invalidArgument + p + ': ' + v);\r\n    }\r\n  }\r\n\r\n  if ((v = obj[p = 'crypto']) !== void 0) {\r\n    if (v === true || v === false || v === 0 || v === 1) {\r\n      if (v) {\r\n        if (typeof crypto != 'undefined' && crypto &&\r\n          (crypto.getRandomValues || crypto.randomBytes)) {\r\n          this[p] = true;\r\n        } else {\r\n          throw Error(cryptoUnavailable);\r\n        }\r\n      } else {\r\n        this[p] = false;\r\n      }\r\n    } else {\r\n      throw Error(invalidArgument + p + ': ' + v);\r\n    }\r\n  }\r\n\r\n  return this;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction cos(x) {\r\n  return new this(x).cos();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction cosh(x) {\r\n  return new this(x).cosh();\r\n}\r\n\r\n\r\n/*\r\n * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n * constructor.\r\n *\r\n */\r\nfunction clone(obj) {\r\n  var i, p, ps;\r\n\r\n  /*\r\n   * The Decimal constructor and exported function.\r\n   * Return a new Decimal instance.\r\n   *\r\n   * v {number|string|Decimal} A numeric value.\r\n   *\r\n   */\r\n  function Decimal(v) {\r\n    var e, i, t,\r\n      x = this;\r\n\r\n    // Decimal called without new.\r\n    if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n    // which points to Object.\r\n    x.constructor = Decimal;\r\n\r\n    // Duplicate.\r\n    if (v instanceof Decimal) {\r\n      x.s = v.s;\r\n      x.e = v.e;\r\n      x.d = (v = v.d) ? v.slice() : v;\r\n      return;\r\n    }\r\n\r\n    t = typeof v;\r\n\r\n    if (t === 'number') {\r\n      if (v === 0) {\r\n        x.s = 1 / v < 0 ? -1 : 1;\r\n        x.e = 0;\r\n        x.d = [0];\r\n        return;\r\n      }\r\n\r\n      if (v < 0) {\r\n        v = -v;\r\n        x.s = -1;\r\n      } else {\r\n        x.s = 1;\r\n      }\r\n\r\n      // Fast path for small integers.\r\n      if (v === ~~v && v < 1e7) {\r\n        for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n        x.e = e;\r\n        x.d = [v];\r\n        return;\r\n\r\n      // Infinity, NaN.\r\n      } else if (v * 0 !== 0) {\r\n        if (!v) x.s = NaN;\r\n        x.e = NaN;\r\n        x.d = null;\r\n        return;\r\n      }\r\n\r\n      return parseDecimal(x, v.toString());\r\n\r\n    } else if (t !== 'string') {\r\n      throw Error(invalidArgument + v);\r\n    }\r\n\r\n    // Minus sign?\r\n    if (v.charCodeAt(0) === 45) {\r\n      v = v.slice(1);\r\n      x.s = -1;\r\n    } else {\r\n      x.s = 1;\r\n    }\r\n\r\n    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n  }\r\n\r\n  Decimal.prototype = P;\r\n\r\n  Decimal.ROUND_UP = 0;\r\n  Decimal.ROUND_DOWN = 1;\r\n  Decimal.ROUND_CEIL = 2;\r\n  Decimal.ROUND_FLOOR = 3;\r\n  Decimal.ROUND_HALF_UP = 4;\r\n  Decimal.ROUND_HALF_DOWN = 5;\r\n  Decimal.ROUND_HALF_EVEN = 6;\r\n  Decimal.ROUND_HALF_CEIL = 7;\r\n  Decimal.ROUND_HALF_FLOOR = 8;\r\n  Decimal.EUCLID = 9;\r\n\r\n  Decimal.config = Decimal.set = config;\r\n  Decimal.clone = clone;\r\n\r\n  Decimal.abs = abs;\r\n  Decimal.acos = acos;\r\n  Decimal.acosh = acosh;        // ES6\r\n  Decimal.add = add;\r\n  Decimal.asin = asin;\r\n  Decimal.asinh = asinh;        // ES6\r\n  Decimal.atan = atan;\r\n  Decimal.atanh = atanh;        // ES6\r\n  Decimal.atan2 = atan2;\r\n  Decimal.cbrt = cbrt;          // ES6\r\n  Decimal.ceil = ceil;\r\n  Decimal.cos = cos;\r\n  Decimal.cosh = cosh;          // ES6\r\n  Decimal.div = div;\r\n  Decimal.exp = exp;\r\n  Decimal.floor = floor;\r\n  Decimal.hypot = hypot;        // ES6\r\n  Decimal.ln = ln;\r\n  Decimal.log = log;\r\n  Decimal.log10 = log10;        // ES6\r\n  Decimal.log2 = log2;          // ES6\r\n  Decimal.max = max;\r\n  Decimal.min = min;\r\n  Decimal.mod = mod;\r\n  Decimal.mul = mul;\r\n  Decimal.pow = pow;\r\n  Decimal.random = random;\r\n  Decimal.round = round;\r\n  Decimal.sign = sign;          // ES6\r\n  Decimal.sin = sin;\r\n  Decimal.sinh = sinh;          // ES6\r\n  Decimal.sqrt = sqrt;\r\n  Decimal.sub = sub;\r\n  Decimal.tan = tan;\r\n  Decimal.tanh = tanh;          // ES6\r\n  Decimal.trunc = trunc;        // ES6\r\n\r\n  if (obj === void 0) obj = {};\r\n  if (obj) {\r\n    ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n    for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n  }\r\n\r\n  Decimal.config(obj);\r\n\r\n  return Decimal;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction div(x, y) {\r\n  return new this(x).div(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n *\r\n */\r\nfunction exp(x) {\r\n  return new this(x).exp();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction floor(x) {\r\n  return finalise(x = new this(x), x.e + 1, 3);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n *\r\n */\r\nfunction hypot() {\r\n  var i, n,\r\n    t = new this(0);\r\n\r\n  external = false;\r\n\r\n  for (i = 0; i < arguments.length;) {\r\n    n = new this(arguments[i++]);\r\n    if (!n.d) {\r\n      if (n.s) {\r\n        external = true;\r\n        return new this(1 / 0);\r\n      }\r\n      t = n;\r\n    } else if (t.d) {\r\n      t = t.plus(n.times(n));\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return t.sqrt();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction ln(x) {\r\n  return new this(x).ln();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * log[y](x)\r\n *\r\n * x {number|string|Decimal} The argument of the logarithm.\r\n * y {number|string|Decimal} The base of the logarithm.\r\n *\r\n */\r\nfunction log(x, y) {\r\n  return new this(x).log(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction log2(x) {\r\n  return new this(x).log(2);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction log10(x) {\r\n  return new this(x).log(10);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */\r\nfunction max() {\r\n  return maxOrMin(this, arguments, 'lt');\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */\r\nfunction min() {\r\n  return maxOrMin(this, arguments, 'gt');\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction mod(x, y) {\r\n  return new this(x).mod(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction mul(x, y) {\r\n  return new this(x).mul(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The base.\r\n * y {number|string|Decimal} The exponent.\r\n *\r\n */\r\nfunction pow(x, y) {\r\n  return new this(x).pow(y);\r\n}\r\n\r\n\r\n/*\r\n * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n * are produced).\r\n *\r\n * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n *\r\n */\r\nfunction random(sd) {\r\n  var d, e, k, n,\r\n    i = 0,\r\n    r = new this(1),\r\n    rd = [];\r\n\r\n  if (sd === void 0) sd = this.precision;\r\n  else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n  k = Math.ceil(sd / LOG_BASE);\r\n\r\n  if (!this.crypto) {\r\n    for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n  // Browsers supporting crypto.getRandomValues.\r\n  } else if (crypto.getRandomValues) {\r\n    d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n    for (; i < k;) {\r\n      n = d[i];\r\n\r\n      // 0 <= n < 4294967296\r\n      // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n      if (n >= 4.29e9) {\r\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n      } else {\r\n\r\n        // 0 <= n <= 4289999999\r\n        // 0 <= (n % 1e7) <= 9999999\r\n        rd[i++] = n % 1e7;\r\n      }\r\n    }\r\n\r\n  // Node.js supporting crypto.randomBytes.\r\n  } else if (crypto.randomBytes) {\r\n\r\n    // buffer\r\n    d = crypto.randomBytes(k *= 4);\r\n\r\n    for (; i < k;) {\r\n\r\n      // 0 <= n < 2147483648\r\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n      // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n      if (n >= 2.14e9) {\r\n        crypto.randomBytes(4).copy(d, i);\r\n      } else {\r\n\r\n        // 0 <= n <= 2139999999\r\n        // 0 <= (n % 1e7) <= 9999999\r\n        rd.push(n % 1e7);\r\n        i += 4;\r\n      }\r\n    }\r\n\r\n    i = k / 4;\r\n  } else {\r\n    throw Error(cryptoUnavailable);\r\n  }\r\n\r\n  k = rd[--i];\r\n  sd %= LOG_BASE;\r\n\r\n  // Convert trailing digits to zeros according to sd.\r\n  if (k && sd) {\r\n    n = mathpow(10, LOG_BASE - sd);\r\n    rd[i] = (k / n | 0) * n;\r\n  }\r\n\r\n  // Remove trailing words which are zero.\r\n  for (; rd[i] === 0; i--) rd.pop();\r\n\r\n  // Zero?\r\n  if (i < 0) {\r\n    e = 0;\r\n    rd = [0];\r\n  } else {\r\n    e = -1;\r\n\r\n    // Remove leading words which are zero and adjust exponent accordingly.\r\n    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n    // Count the digits of the first word of rd to determine leading zeros.\r\n    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n    // Adjust the exponent for leading zeros of the first word of rd.\r\n    if (k < LOG_BASE) e -= LOG_BASE - k;\r\n  }\r\n\r\n  r.e = e;\r\n  r.d = rd;\r\n\r\n  return r;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n *\r\n * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction round(x) {\r\n  return finalise(x = new this(x), x.e + 1, this.rounding);\r\n}\r\n\r\n\r\n/*\r\n * Return\r\n *   1    if x > 0,\r\n *  -1    if x < 0,\r\n *   0    if x is 0,\r\n *  -0    if x is -0,\r\n *   NaN  otherwise\r\n *\r\n */\r\nfunction sign(x) {\r\n  x = new this(x);\r\n  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction sin(x) {\r\n  return new this(x).sin();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction sinh(x) {\r\n  return new this(x).sinh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction sqrt(x) {\r\n  return new this(x).sqrt();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction sub(x, y) {\r\n  return new this(x).sub(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction tan(x) {\r\n  return new this(x).tan();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction tanh(x) {\r\n  return new this(x).tanh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` truncated to an integer.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction trunc(x) {\r\n  return finalise(x = new this(x), x.e + 1, 1);\r\n}\r\n\r\n\r\n// Create and configure initial Decimal constructor.\r\nDecimal = clone(defaults);\r\n\r\n// Create the internal constants from their string values.\r\nLN10 = new Decimal(ln10);\r\nPI = new Decimal(pi);\r\n\r\nexport default Decimal;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/decimal.js/decimal.es6.js\n// module id = 2\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 3\n// module chunks = 0","module.exports = {\n\t\"short\": [\n\t\t\"\",\n\t\t\"K\",\n\t\t\"M\",\n\t\t\"Md\",\n\t\t\"B\",\n\t\t\"Bd\",\n\t\t\"T\",\n\t\t\"Td\",\n\t\t\"Qa\",\n\t\t\"Qad\",\n\t\t\"Qi\",\n\t\t\"Qid\",\n\t\t\"Sx\",\n\t\t\"Sxd\",\n\t\t\"Sp\",\n\t\t\"Spd\",\n\t\t\"Oc\",\n\t\t\"Od\",\n\t\t\"No\",\n\t\t\"Nd\",\n\t\t\"Dc\",\n\t\t\"Dd\",\n\t\t\"UDc\",\n\t\t\"UDd\",\n\t\t\"DDc\",\n\t\t\"DDd\",\n\t\t\"TDc\",\n\t\t\"TDd\",\n\t\t\"QaDc\",\n\t\t\"QaDd\",\n\t\t\"QiDc\",\n\t\t\"QiDd\",\n\t\t\"SxDc\",\n\t\t\"SxDd\",\n\t\t\"SpDc\",\n\t\t\"SpDd\",\n\t\t\"ODc\",\n\t\t\"ODd\",\n\t\t\"NDc\",\n\t\t\"NDd\",\n\t\t\"Vi\",\n\t\t\"Vd\",\n\t\t\"UVi\",\n\t\t\"UVd\",\n\t\t\"DVi\",\n\t\t\"DVd\",\n\t\t\"TVi\",\n\t\t\"TVd\",\n\t\t\"QaVi\",\n\t\t\"QaVd\",\n\t\t\"QiVi\",\n\t\t\"QiVd\",\n\t\t\"SxVi\",\n\t\t\"SxVd\",\n\t\t\"SpVi\",\n\t\t\"SpVd\",\n\t\t\"OVi\",\n\t\t\"OVd\",\n\t\t\"NVi\",\n\t\t\"NVd\",\n\t\t\"Tg\",\n\t\t\"TD\",\n\t\t\"UTg\",\n\t\t\"UTD\",\n\t\t\"DTg\",\n\t\t\"DTD\",\n\t\t\"TTg\",\n\t\t\"TTD\",\n\t\t\"QaTg\",\n\t\t\"QaTD\",\n\t\t\"QiTg\",\n\t\t\"QiTD\",\n\t\t\"SxTg\",\n\t\t\"SxTD\",\n\t\t\"SpTg\",\n\t\t\"SpTD\",\n\t\t\"OTg\",\n\t\t\"OTD\",\n\t\t\"NTg\",\n\t\t\"NTD\",\n\t\t\"Qd\",\n\t\t\"QD\",\n\t\t\"UQd\",\n\t\t\"UQD\",\n\t\t\"DQd\",\n\t\t\"DQD\",\n\t\t\"TQd\",\n\t\t\"TQD\",\n\t\t\"QaQd\",\n\t\t\"QaQD\"\n\t],\n\t\"full\": [\n\t\t\"\",\n\t\t\" thousand\",\n\t\t\" million\",\n\t\t\" milliard\",\n\t\t\" billion\",\n\t\t\" billiard\",\n\t\t\" trillion\",\n\t\t\" trilliard\",\n\t\t\" quadrillion\",\n\t\t\" quadrilliard\",\n\t\t\" quintillion\",\n\t\t\" quintilliard\",\n\t\t\" sextillion\",\n\t\t\" sextilliard\",\n\t\t\" septillion\",\n\t\t\" septilliard\",\n\t\t\" octillion\",\n\t\t\" octilliard\",\n\t\t\" nonillion\",\n\t\t\" nonilliard\",\n\t\t\" decillion\",\n\t\t\" decilliard\",\n\t\t\" undecillion\",\n\t\t\" undecilliard\",\n\t\t\" duodecillion\",\n\t\t\" duodecilliard\",\n\t\t\" tredecillion\",\n\t\t\" tredecilliard\",\n\t\t\" quattuordecillion\",\n\t\t\" quattuordecilliard\",\n\t\t\" quinquadecillion\",\n\t\t\" quinquadecilliard\",\n\t\t\" sedecillion\",\n\t\t\" sedecilliard\",\n\t\t\" septendecillion\",\n\t\t\" septendecilliard\",\n\t\t\" octodecillion\",\n\t\t\" octodecilliard\",\n\t\t\" novendecillion\",\n\t\t\" novendecilliard\",\n\t\t\" vigintillion\",\n\t\t\" vigintilliard\",\n\t\t\" unvigintillion\",\n\t\t\" unvigintilliard\",\n\t\t\" duovigintillion\",\n\t\t\" duovigintilliard\",\n\t\t\" tresvigintillion\",\n\t\t\" tresvigintilliard\",\n\t\t\" quattuorvigintillion\",\n\t\t\" quattuorvigintilliard\",\n\t\t\" quinquavigintillion\",\n\t\t\" quinquavigintilliard\",\n\t\t\" sesvigintillion\",\n\t\t\" sesvigintilliard\",\n\t\t\" septemvigintillion\",\n\t\t\" septemvigintilliard\",\n\t\t\" octovigintillion\",\n\t\t\" octovigintilliard\",\n\t\t\" novemvigintillion\",\n\t\t\" novemvigintilliard\",\n\t\t\" trigintillion\",\n\t\t\" trigintilliard\",\n\t\t\" untrigintillion\",\n\t\t\" untrigintilliard\",\n\t\t\" duotrigintillion\",\n\t\t\" duotrigintilliard\",\n\t\t\" trestrigintillion\",\n\t\t\" trestrigintilliard\",\n\t\t\" quattuortrigintillion\",\n\t\t\" quattuortrigintilliard\",\n\t\t\" quinquatrigintillion\",\n\t\t\" quinquatrigintilliard\",\n\t\t\" sestrigintillion\",\n\t\t\" sestrigintilliard\",\n\t\t\" septentrigintillion\",\n\t\t\" septentrigintilliard\",\n\t\t\" octotrigintillion\",\n\t\t\" octotrigintilliard\",\n\t\t\" noventrigintillion\",\n\t\t\" noventrigintilliard\",\n\t\t\" quadragintillion\",\n\t\t\" quadragintilliard\",\n\t\t\" unquadragintillion\",\n\t\t\" unquadragintilliard\"\n\t]\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/long-scale-suffixes.json\n// module id = 4\n// module chunks = 0","module.exports = {\n\t\"short\": [\n\t\t\"\",\n\t\t\"K\",\n\t\t\"M\",\n\t\t\"B\",\n\t\t\"T\",\n\t\t\"Qa\",\n\t\t\"Qi\",\n\t\t\"Sx\",\n\t\t\"Sp\",\n\t\t\"Oc\",\n\t\t\"No\",\n\t\t\"Dc\",\n\t\t\"UDc\",\n\t\t\"DDc\",\n\t\t\"TDc\",\n\t\t\"QaDc\",\n\t\t\"QiDc\",\n\t\t\"SxDc\",\n\t\t\"SpDc\",\n\t\t\"ODc\",\n\t\t\"NDc\",\n\t\t\"Vi\",\n\t\t\"UVi\",\n\t\t\"DVi\",\n\t\t\"TVi\",\n\t\t\"QaVi\",\n\t\t\"QiVi\",\n\t\t\"SxVi\",\n\t\t\"SpVi\",\n\t\t\"OVi\",\n\t\t\"NVi\",\n\t\t\"Tg\",\n\t\t\"UTg\",\n\t\t\"DTg\",\n\t\t\"TTg\",\n\t\t\"QaTg\",\n\t\t\"QiTg\",\n\t\t\"SxTg\",\n\t\t\"SpTg\",\n\t\t\"OTg\",\n\t\t\"NTg\",\n\t\t\"Qd\",\n\t\t\"UQd\",\n\t\t\"DQd\",\n\t\t\"TQd\",\n\t\t\"QaQd\",\n\t\t\"QiQd\",\n\t\t\"SxQd\",\n\t\t\"SpQd\",\n\t\t\"OQd\",\n\t\t\"NQd\",\n\t\t\"Qq\",\n\t\t\"UQq\",\n\t\t\"DQq\",\n\t\t\"TQq\",\n\t\t\"QaQq\",\n\t\t\"QiQq\",\n\t\t\"SxQq\",\n\t\t\"SpQq\",\n\t\t\"OQq\",\n\t\t\"NQq\",\n\t\t\"Sg\",\n\t\t\"USg\",\n\t\t\"DSg\",\n\t\t\"TSg\",\n\t\t\"QaSg\",\n\t\t\"QiSg\",\n\t\t\"SxSg\",\n\t\t\"SpSg\",\n\t\t\"OSg\",\n\t\t\"NSg\",\n\t\t\"St\",\n\t\t\"USt\",\n\t\t\"DSt\",\n\t\t\"TSt\",\n\t\t\"QaSt\",\n\t\t\"QiSt\",\n\t\t\"SxSt\",\n\t\t\"SpSt\",\n\t\t\"OSt\",\n\t\t\"NSt\",\n\t\t\"Og\",\n\t\t\"UOg\",\n\t\t\"DOg\",\n\t\t\"TOg\",\n\t\t\"QaOg\",\n\t\t\"QiOg\",\n\t\t\"SxOg\",\n\t\t\"SpOg\",\n\t\t\"OOg\",\n\t\t\"NOg\"\n\t],\n\t\"full\": [\n\t\t\"\",\n\t\t\" thousand\",\n\t\t\" million\",\n\t\t\" billion\",\n\t\t\" trillion\",\n\t\t\" quadrillion\",\n\t\t\" quintillion\",\n\t\t\" sextillion\",\n\t\t\" septillion\",\n\t\t\" octillion\",\n\t\t\" nonillion\",\n\t\t\" decillion\",\n\t\t\" undecillion\",\n\t\t\" duodecillion\",\n\t\t\" tredecillion\",\n\t\t\" quattuordecillion\",\n\t\t\" quinquadecillion\",\n\t\t\" sedecillion\",\n\t\t\" septendecillion\",\n\t\t\" octodecillion\",\n\t\t\" novendecillion\",\n\t\t\" vigintillion\",\n\t\t\" unvigintillion\",\n\t\t\" duovigintillion\",\n\t\t\" tresvigintillion\",\n\t\t\" quattuorvigintillion\",\n\t\t\" quinquavigintillion\",\n\t\t\" sesvigintillion\",\n\t\t\" septemvigintillion\",\n\t\t\" octovigintillion\",\n\t\t\" novemvigintillion\",\n\t\t\" trigintillion\",\n\t\t\" untrigintillion\",\n\t\t\" duotrigintillion\",\n\t\t\" trestrigintillion\",\n\t\t\" quattuortrigintillion\",\n\t\t\" quinquatrigintillion\",\n\t\t\" sestrigintillion\",\n\t\t\" septentrigintillion\",\n\t\t\" octotrigintillion\",\n\t\t\" noventrigintillion\",\n\t\t\" quadragintillion\",\n\t\t\" unquadragintillion\",\n\t\t\" duoquadragintillion\",\n\t\t\" tresquadragintillion\",\n\t\t\" quattuorquadragintillion\",\n\t\t\" quinquaquadragintillion\",\n\t\t\" sesquadragintillion\",\n\t\t\" septenquadragintillion\",\n\t\t\" octoquadragintillion\",\n\t\t\" novenquadragintillion\",\n\t\t\" quinquagintillion\",\n\t\t\" unquinquagintillion\",\n\t\t\" duoquinquagintillion\",\n\t\t\" tresquinquagintillion\",\n\t\t\" quattuorquinquagintillion\",\n\t\t\" quinquaquinquagintillion\",\n\t\t\" sesquinquagintillion\",\n\t\t\" septenquinquagintillion\",\n\t\t\" octoquinquagintillion\",\n\t\t\" novenquinquagintillion\",\n\t\t\" sexagintillion\",\n\t\t\" unsexagintillion\",\n\t\t\" duosexagintillion\",\n\t\t\" tresexagintillion\",\n\t\t\" quattuorsexagintillion\",\n\t\t\" quinquasexagintillion\",\n\t\t\" sesexagintillion\",\n\t\t\" septensexagintillion\",\n\t\t\" octosexagintillion\",\n\t\t\" novensexagintillion\",\n\t\t\" septuagintillion\",\n\t\t\" unseptuagintillion\",\n\t\t\" duoseptuagintillion\",\n\t\t\" treseptuagintillion\",\n\t\t\" quattuorseptuagintillion\",\n\t\t\" quinquaseptuagintillion\",\n\t\t\" seseptuagintillion\",\n\t\t\" septenseptuagintillion\",\n\t\t\" octoseptuagintillion\",\n\t\t\" novenseptuagintillion\",\n\t\t\" octogintillion\",\n\t\t\" unoctogintillion\",\n\t\t\" duooctogintillion\"\n\t]\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/standard-suffixes.json\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}